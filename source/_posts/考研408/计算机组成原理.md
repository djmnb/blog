---
title: 计算机组成原理
date: 2023-6-27
tags: 
  - 计算机组成原理
  - 需要复习
---

# 计算机系统概述

## 计算机系统层次结构

### 计算机系统的组成

硬件系统+软件系统,   硬件是指有形的物理设备, 软件是指硬件上运行的程序和数据

### 计算机组成和计算机体系结构

计算机组成（Computer Organization）和计算机体系结构（Computer Architecture）是两个相关但又有所区别的领域。它们都关注计算机系统的设计，但从不同的角度。以下是这两者的主要差异：

1. **定义与焦点**：
   - **计算机体系结构**：关注系统的高层设计，如指令集、数据类型、寻址模式和计算机的功能抽象。简而言之，它是描述硬件和软件如何交互以及如何实现功能的接口和规范。
   - **计算机组成**：更注重硬件组件的具体实现和组织，如数据路径、控制逻辑、内存组织、输入/输出处理和流水线设计等。

2. **抽象层级**：
   - **计算机体系结构**：在更高的抽象层级。它定义了指令集以及如何进行高级运算，但不涉及具体如何在硬件上实现这些运算。
   - **计算机组成**：在较低的抽象层级。它关注如何使用电子部件和逻辑来实现体系结构中定义的功能。

3. **应用领域**：
   - **计算机体系结构**：对于编译器设计师、操作系统开发者和应用程序开发者来说，理解体系结构是非常重要的，因为他们需要确保他们的软件与给定的体系结构兼容。
   - **计算机组成**：对于硬件设计师和电子工程师来说，理解计算机组成是关键的，因为他们需要构建和组织硬件来满足体系结构的要求。

4. **示例**：
   - **计算机体系结构**：定义一台机器应该有哪些指令（例如，加法、乘法、加载、存储等）以及这些指令应该如何工作。
   - **计算机组成**：描述如何在硬件中实现这些指令，例如，为了实现加法指令，我们可能需要一个加法器、数据寄存器和其他控制逻辑。

总之，计算机体系结构关注“设计的是什么”，而计算机组成关注“如何实现这个设计”。两者紧密相关，但各自关注不同的设计和实现细节。

## 概念

* **存储元件**用来存储一位二进制代码,   **存储单元**包含若干个存储元件,  它能够包含一连串二进制代码,  这串二进制代码被称为**存储字**,  位数称为**存储字长**, 存储字长一般是一个字节或者是字节的偶数倍
* 机器字长(简称为字长)  是指一次整数运算能够处理的位数, 通常等于运算器位数,  



## 做题总结

* CPU执行时间 = 总指令时间周期数/主频  = 总指令时间周期数*时钟周期 = cpi * 指令数量 / 主频
* MIPS = 指令条数 / (执行时间 * 10 ^ 6) = x/(x\*CPI\*T * 10^6 ) = 主频 / (CPI*10^6) 
* (M,G,T,P,E,Z)FLOPS  每秒执行浮点数次数   M = 10^6 G = 10^9 T = 10^12 P = 10^15 E = 10^18 Z = 10^21

# 数据的表示和运算

## 数制与编码

### 采用二进制编码原因

计算机采用二进制编码有多种原因，其中最主要的是基于实际硬件实现的便利性和效率。以下是使用二进制的主要原因：

1. **简化硬件设计**：二进制只有两个状态：0 和 1，这与电子开关的基本工作原理相匹配，即开（ON）或关（OFF）。使用二进制编码可以轻松地用这些开关状态表示信息。例如，一个开关处于关闭状态可以表示0，而开启状态可以表示1。

2. **可靠性**：由于只有两种状态，二进制系统在处理噪声或其他干扰时更加鲁棒。例如，一个模拟系统可能受到细微的电压变化的影响，而二进制系统只需区分两种状态，因此更能够容忍小的误差或干扰。

3. **逻辑运算**：基于二进制的电子逻辑门（如AND、OR和NOT门）的设计和实现相对简单。这些逻辑门是计算机运行的基础。

4. **简化算术运算**：在二进制下，算术运算（如加法和乘法）可以通过简单的位操作实现，这在硬件上更易于实现。

5. **存储和传输**：二进制编码使得信息的存储和传输更加一致和简单。不论是处理文本、图像、音频还是视频，所有信息最终都可以转换为二进制形式并通过相同的基础硬件进行处理。

6. **历史和技术进展**：早期的计算机和计算机设备（如继电器和真空管）更容易以二进制方式工作。随着技术的进步，这种方法已经被证明是非常有效的，因此被继续沿用。

尽管二进制是最常用的编码方式，但在特定的应用和技术中，也有使用其他编码系统（如三进制、四进制等）的尝试。然而，由于上述原因，二进制已经成为了主流的选择。

### 进制转换

进制转换是计算机科学中的基础概念，尤其在考研408中也是经常被考察的内容。以下是常用的进制转换方法，包括整数和小数部分：

1. **二进制与十进制之间的转换**：
   - **整数部分**：
     - 从二进制转为十进制：按权展开，即从最低位开始，每一位的值乘以2的相应次方，然后求和。
     - 从十进制转为二进制：通过连续除以2并取余数的方法。**除基取余法**
   - **小数部分**：
     - 从二进制转为十进制：从小数点后的第一位开始，每一位的值乘以2的相应负次方，然后求和。
     - 从十进制转为二进制：通过连续乘以2并取整数部分的方法。**乘积取整法**

2. **二进制与八进制之间的转换**：
   - **整数部分**：每三位二进制数对应一位八进制数。
   - **小数部分**：同样，每三位二进制小数对应一位八进制小数。

3. **二进制与十六进制之间的转换**：
   - **整数部分**：每四位二进制数对应一位十六进制数。
   - **小数部分**：同样，每四位二进制小数对应一位十六进制小数。

4. **十进制与八进制、十六进制之间的转换**：
   - 通常先将十进制数转为二进制，然后再从二进制转为八进制或十六进制。

注意：在进行进制转换时，尤其是涉及小数部分，可能会遇到无法精确转换的情况，这时通常会取一个近似值。

在考研408的复习中，掌握这些基本的进制转换方法是非常重要的，因为它们是很多计算机科学概念的基础。

### 真值和机器数

1. **真值**：
   - 真值是一个数学上的概念，表示数的实际值，包括它的正负。(也就是带有"+","-"的数)
   - 例如，+5的真值是+5，-5的真值是-5。
2. **机器数**：
   - 机器数是计算机中用来表示一个数的二进制形式。对于正数，其真值和机器数是相同的；但对于负数，机器数是其补码形式。(使用数字代替正负号)
   - 在大多数现代计算机系统中，负数的表示采用的是“二进制补码”形式。这意味着负数的机器数是其绝对值的二进制反码加1得到的。
   - 例如，假设我们要在一个8位的系统中表示数字-5：
     1. +5的二进制形式是：0101
     2. 取反得到：1010
     3. 加1得到：1011 因此，-5的机器数是1011。

### 原码,反码,补码,移码

当我们在计算机中表示和处理整数，特别是负整数时，就会涉及到原码、反码、补码和移码这些表示方法。以下是这些概念的总结：

1. **原码**：
   - 原码是最直观的二进制表示方法。最高位是符号位：0表示正数，1表示负数。其余位表示该数的绝对值。
   - 例如：+7的原码为：0111，-7的原码为：1111（假设我们使用4位表示）。

2. **反码**：
   - 正数的反码与其原码相同。
   - 负数的反码是保持符号位不变，然后对原码的数值部分取反。
   - 例如：+7的反码为：0111，-7的反码为：1000。

3. **补码**：
   - 正数的补码与其原码相同。
   - 负数的补码是其反码加1。
   - 例如：+7的补码为：0111，-7的补码为：1001。
   - 补码是现代计算机中最常用的表示方法，因为它使得加法和减法运算更为简单。

4. **移码**：
   - 移码常用于浮点数的指数部分。它是通过将原码加上一个固定的偏移量（通常是2的(n-1)次方，其中n是位数）来得到的。
   - 对于4位表示，偏移量是2^3 = 8。所以，+7的移码是：0111 + 1000 = 1111，-7的移码是：1111 + 1000 = 0111。
   - 移码的主要优点是它可以使得负数的排序和正数相同。



## 运算

### 移位运算

* 逻辑移位
* 算数移位
* 循环移位

### 加减运算

* 原码加减法(了解即可)
* 补码加减法

溢出方法判别  两个相同符号位运算数的结果符号位不同 就是溢出

* 一位符号法:  两种情况  1 1 0  和 0 0 1  所以表达式为 V = $AB\overline{S} + \overline{A} \overline{B} S$
* 双符号法:  只有两个符号位不同的时候才算溢出  1 0 代表负溢出  0 1 代表正溢出  1 1 代表负数不溢出  0 0 代表正数不溢出
* 符号进位与最高位进位判别法 (做异或操作, 0 代表不溢出 1 代表溢出)  

**无论采用什么方法判断溢出,   存储的时候都是存放一位符号位,  只是在运算的时候,才把符号位的值同时放到ALU中(因为一个正确的数, 双符号位相同), 所以也就是说只在ALU中采用双符号位**

### 乘除运算

#### 原码一位乘法

符号位和数值为分开计算   乘积符号位由符号位运算得出  数值位由数值绝对值计算得出  

这个过程其实就是累加的过程

1. 部分积和被乘数在计算过程中采用双符号位,部分积初始值为0, 部分积最终存放的是高位数值
2. 如果当前乘数最低位为1, 则部分积加上被被乘数,   然后部分积和乘数都**逻辑右移一位** ( 部分积右移 溢出的是低位部分积)
3. 重复步骤2  n次
4. 将最终部分积高位与低位合并的结果的符号位设置成 符号位异或的结果

**可以发现一共做n次加法 n次移动**



#### 补码一位乘法(Booth算法)

这个算法步骤中符号位是参与运算的, 而且运算数都是补码计算, 它和原码一位乘法累加过程相似, 但是每一步是加法还是减法是需要另外计算的

1. 部分积和被乘数在计算过程中采用双符号位,部分积初始值为0, 部分积最终存放的是高位数值
2. 乘数末尾新增一位0(不参与计算,用于确定是加被乘数还是减被乘数) 
3.  靠乘数最后两位选出部分积是加被乘数还是减被乘数, 1 1 和 0 0 代表 + 0 ,  1 0 代表 - 被乘数 , 0 1 代表 + 被乘数 
4. 将乘数 逻辑右移, 部分积 **算数右移一位**(溢出的是低位部分积)
5. 重复3,4步骤 n次
6. 最后将部分积  再进行一次3步骤  
7. 最终部分积高位与低位合并的结果 **就是计算结果的补码**

**可以发现一共做n+1次加法 n次移动**



> 我发现一个问题就是, 书上貌似都是小数乘法, 但是如果是整数乘法,我感觉这些乘法是不太对的 我觉得应该要左移被乘数然后和部分积相加,   或者说需要改一下第7步, 低位就是最终结果



#### 原码除法(不恢复余数法)

除法其实就是做减法

数值位计算过程

1. 取两个数的绝对值
2. 先将被除数的绝对值-除数绝对值 相当于 +除数绝对值的补码
3. 根据计算出来的值称为余数  如果是正数  商的最后一位为1  商和余数都左移一位  然后-除数绝对值,  如果是负数 商的最后一位为0  商和余数都左移一位  然后 + 除数绝对值  (**逻辑左移**)
4. 重复 3步骤 n 次  (最后一步得到余数后, 还要给商设置一次值,根据3的规则)
5. 如果最后的余数为负数, 需要再加上除数绝对值
6. 最后将符号位做异或运算当做商的符号位

#### 补码除法(加减交替法)

符号位与数值位一起参加运算

1. 如果被除数与除数同号就 - 除数, 异号就加上除数
2. 根据计算出来的值称为余数  如果与除数同号就  商的最后一位为1  商和余数都左移一位  然后-除数,  如果与除数异号就 商的最后一位为0  商和余数都左移一位  然后 + 除数  (**算数左移**)
3. 重复 2 步骤 n次( 最后一步得到余数后, 如果对商没有特殊要求,  最后一位置1 )



## 数据类型转换

### 有符号数与无符号数相互转换

二者在内存中的二进制表示方式还是相同,  但是解释方式不同

```c++
int a = -1;
unsigned int b = (unsigned int)a;  // b = 2^32-1
```

### 不同字长整数之间的转换

大字长向小字长转换 直接截取大字长低位给小字长

```c++
int a = (int)0b11000000000000000000000000000000; //-1073741824
short b = (short)a; // 0
```

小字长向大字长转换  将小字长数据放入到大字长低位,  高位用小字长符号位填充(如果小字长是无符号数就用0填充)

(char 类型就是8位无符号整数)



## 数据的存储与排列

### 大端小端存储

由于每个数据只会有一个内存地址, 如果是多字节数据接下来的连续若干个地址构成了这个数据,  这样就会涉及到排列问题

* 大端方式   从大大小排列  高位在前  低位在后   也就是高位在低地址, 低位在高地址
* 小端方式  从小到大排列  低位在前 高位在后  也就是低位在低地址 高位在高地址

如果地址从左到右依次增加,  那么大端方式的话 就相当于顺序存放一个数,   小端就相当于逆序**(字节内有序)**

```c++
int a = 0x01234567
// 01 23 45 67  大端
// 67 45 23 01  小端 
```

### 边界对齐方式存储

* 边界对齐方式能够使  半字数据和字数据都能各自存放在一个存储单元中, 不会分布在不同的存储单元中, 但是会浪费一定的空间, 优点是提高指令和数据的读写速度
* 边界不对齐方式  可以充分利用存储空间,   但是一个字或者半字数据会存放在不同的存储单元中, 这样读取一个字或者半字的指令或者数据的时候,需要多次访存

## 浮点数的表示与运算

> 浮点数就是小数点位置不固定的数,  这里的不固定不是指小数点会真正的移动,  而是指通过缩放数据, 让小数点逻辑移动

### 表示格式

符号位 阶码  尾数  

* 符号位取值 0 1 代表正负
* 阶码或者叫指数   用移码表示  这里还隐约包含了  基数  通常采用 2    阶码就反应了浮点数小数点实际位置
* 尾数的位数反应了精度  尾数部分通常用原码表示

### 浮点数的规格化

定义:  通过调整尾数和阶码的大小,  让非零浮点数的尾数部分最高位是一个有效值

规范化的尾数绝对值肯定满足   1/R <= |M| <= 1   R代表基数   M代表尾数值

### IEEE754标准

IEEE 754标准是一个定义浮点数算术的国际标准，广泛应用于计算机和数字系统中。以下是该标准的总结：

1. **基本组成**：
   - **符号位（Sign bit）**：决定浮点数的正负。0表示正数，1表示负数。
   - **指数（Exponent）**：表示浮点数的阶数。使用一个偏移（bias）格式来表示。2^(n-1) - 1
   - **尾数（Mantissa 或 Fraction）**：表示浮点数的有效数字。

2. **主要格式**：
   - **单精度（32位）**：
     - 符号位：1位
     - 指数：8位，偏移值为127   2^7 -1 
     - 尾数：23位
   - **双精度（64位）**：
     - 符号位：1位
     - 指数：11位，偏移值为1023   2^10 -1 
     - 尾数：52位

3. **特殊值**：
   - **零（0）**：有正零和负零，指数和尾数都为0。
   - **无穷（Infinity）**：正无穷和负无穷，指数为最大值，尾数为0。
   - **NaN（Not a Number）**：表示不是一个数的值，如0除以0的结果。指数为最大值，尾数不为0。

4. **规格化与非规格化数**：
   - **规格化数**：**尾数部分的隐含的最高位是1**。例如，对于单精度，它是1.xxxxx的形式。
   - **非规格化数**：当指数部分为全0时，表示的数是非规格化的，隐含的最高位是0。这允许表示接近于0的非常小的数。

5. **舍入模式**：
   IEEE 754标准定义了多种舍入模式，包括最近偶数舍入（默认模式）和向正无穷、向负无穷、向零舍入等。

6. **操作和异常**：
   标准定义了浮点数的基本操作（如加、减、乘、除等）以及可能的异常情况（如溢出、下溢、除以零等）和它们的处理方式。

IEEE 754标准为浮点数的表示和运算提供了一个统一和一致的框架，被广泛采用于现代计算机和数字系统中。理解这个标准的基本概念和特点对于计算机科学和工程领域是非常重要的。

### 浮点数的加减运算

对阶:  小阶通过尾数右移 阶码增加 像大阶对其   这样的话会舍弃掉有效位 产生误差影响精度

尾数求和:  将对阶后的尾数运算即可   运算后的尾数不一定是规格化的,  此后还需要规格化

舍入: 在对阶和尾数右规式, 为了保证运算精度, 一般将低位溢出的两位保留下来参加中间运算过程, 最后将运算结果舍入

常见舍入方法:

* 0舍1入法:  类似于四舍五入, 保留位的最高位为0则舍去  保留位的最高位为1 **尾数末位+1**   这样可能导致尾数溢出, 需要再一次右规   
* 恒置1法:  如果保留的两位中 存在一个1, 则**尾数末位设置为1**
* 截断法: 直接舍去

溢出判断:  浮点数的溢出判断是根据阶码来判断的,  如果阶码全0  则表示下溢出,  全1 则表示上溢出

## 浮点数和定点数的区别

浮点数和定点数是数字系统中两种不同的数值表示方法。它们各自有其优点和缺点，适用于不同的应用场景。以下是它们之间的主要区别：

1. **定义**：
   - **浮点数**：浮点数的表示方式类似于科学记数法，其中数值的小数点位置可以“浮动”。一个浮点数由符号位、指数和尾数三部分组成。
   - **定点数**：定点数的小数点位置是固定的。它由整数部分和小数部分组成，小数点的位置在表示中是固定不变的。

2. **表示范围和精度**：
   - **浮点数**：由于其指数的存在，浮点数可以表示非常大或非常小的数值，但精度可能会受到限制，特别是对于非常大或非常小的数值。
   - **定点数**：定点数的表示范围受到其整数和小数部分的位数的限制，但在其表示范围内，精度是固定的。

3. **计算复杂性**：
   - **浮点数**：浮点数的算术运算（如加、减、乘、除）相对复杂，需要专门的硬件支持，如浮点数算术单元（FPU）。
   - **定点数**：定点数的算术运算相对简单，可以在没有专门浮点硬件的系统上高效地执行。

4. **应用场景**：
   - **浮点数**：适用于需要处理大范围数值或高精度计算的应用，如科学计算、图形处理等。
   - **定点数**：常用于嵌入式系统、数字信号处理等领域，其中硬件资源可能有限，但需要快速、确定的计算性能。

5. **硬件和存储**：
   - **浮点数**：通常需要更多的硬件资源和存储空间来表示和处理。
   - **定点数**：通常更加紧凑，需要较少的硬件资源和存储空间。

6. **误差和精度**：
   - **浮点数**：可能会引入舍入误差，特别是在连续的算术运算中。
   - **定点数**：误差通常是固定的，但数值范围受到限制。

总的来说，浮点数和定点数都是数字系统中表示数值的方法，选择哪种方法取决于特定的应用需求、硬件资源和性能要求。



## 做题技巧

* 对于补码反码来说,  数值部分越大, 对应的真值也越大
* 对于正数来说, 反码,补码,原码是相同的, 只有移码不同,  而对于负数来说, 就都有可能不同了,   移码和补码只有符号位相反
* 对于并行加法器来说,  加法器没有区别,  只是进位的产生不再是串行产生了,  而是并行产生, 由一个CLA电路根据各位数值计算而来
* 对于减法运算来说,  低位进位都是1, 代表选用减法运算, 然后减少要取反+1
* 对于边界对齐的计算机来说, 一般按照机器字长来对齐, 不够的就用空白来填
* **对于IEEE754标准, 将其他数据转换为 浮点数的时候,  阶码一定要加上偏移值,   浮点数转换为其他数的时候, 阶码一定要减去偏移值**
* 浮点数变成定点数  尾数左移阶码表示数量    定点数变成浮点数  右移尾数   阶码增加

# 存储器层次结构

# 指令系统

# 中央处理器(CPU)

# 总线

# 输入输出(I/O)系统

# 额外补充



## 组合逻辑电路和时序逻辑电路

组合逻辑电路和时序逻辑电路是数字逻辑设计中的两个基本概念。它们的主要区别在于是否涉及时间或时序的概念。

1. **组合逻辑电路**：

   - **定义**：组合逻辑电路的输出仅仅依赖于当前的输入值，而与先前的输入或状态无关。

   - 特点

     ：

     - 没有记忆功能。
     - 任何时候，相同的输入都会产生相同的输出。

   - **常见元件**：基本逻辑门（如AND、OR、NOT）、多路复用器、解码器、编码器等。

   - **应用**：算术逻辑单元（ALU）、解码器、编码器等。

2. **时序逻辑电路**：

   - **定义**：时序逻辑电路的输出不仅依赖于当前的输入，还依赖于先前的输入或状态。这意味着它具有记忆功能。

   - 特点

     ：

     - 有记忆功能，能够存储信息。
     - 输出取决于当前输入和先前的状态。

   - **常见元件**：触发器（如D触发器、JK触发器、T触发器）、计数器、寄存器、时钟等。

   - **应用**：存储元件、计数器、状态机等。

**总结**：

- 组合逻辑电路是“无记忆”的，其输出完全由当前输入决定。
- 时序逻辑电路具有“记忆”功能，其输出由当前输入和先前的状态共同决定。
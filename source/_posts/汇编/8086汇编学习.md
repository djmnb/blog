---
title: 8086汇编学习
date: 2023-9-15
tags:
  - 汇编
---

# 前言

在考研过程中好好学了一下计算机组成原理,  让我对底层这些东西产生了浓厚的兴趣,  因此就先学学基础汇编



# 基本信息

* 机器字长为 16位    存储字长为16位    地址线20根   数据线16根
* 由于机器字长只有16位,  地址线有20根,  计算物理地址需要特别处理  物理地址 =  段地址*16 + 段内地址    (物理地址表示不唯一)
* AX,BX,CX,DX  都是通用寄存器, 用来存放数据  段地址寄存器有: CS  DS ES SS  偏移地址寄存器有:  SP,BP,SI,DI,IP,BX
* CS:IP  指定下一条执行指令的位置,   SS:SP 指定栈顶位置 (进栈操作 SP-字节数  放入数据, 出栈操作 拿出数据 SP+数据字节数)  DS , ES是数据段位置  
* 数据在内存中都是小端存放



# 寄存器

下面是8086 CPU的主要寄存器及其英文全称和功能：

1. **AX (Accumulator Register)**：累加寄存器。
   - 主要用于算数运算和数据传输。
  
2. **BX (Base Register)**：基址寄存器。
   - 除了可以用于算术运算外，它还经常用于地址运算。 **默认使用ds作为段地址**

3. **CX (Count Register)**：计数寄存器。
   - 通常用于循环计数。
   
4. **DX (Data Register)**：数据寄存器。
   - 用于算数运算和某些特殊指令，如某些I/O操作。

5. **SI (Source Index)**：源索引寄存器。 **默认使用ds作为段地址**
   - 主要用于字符串操作，表示源字符串的地址。

6. **DI (Destination Index)**：目标索引寄存器。**默认使用es作为段地址**
   - 主要用于字符串操作，表示目标字符串的地址。

7. **BP (Base Pointer)**：基指针寄存器。
   - 通常用于基于堆栈的参数和局部变量的地址引用。 **默认使用 ss作为段地址**

8. **SP (Stack Pointer)**：堆栈指针寄存器。
   - 始终指向堆栈的顶部，随着数据的压入和弹出而变化。

此外，8086还有段寄存器，用于段地址运算：

1. **CS (Code Segment)**：代码段寄存器。
   - 指向当前执行代码的段。

2. **DS (Data Segment)**：数据段寄存器。
   - 用于大多数数据操作指令的默认段。

3. **SS (Stack Segment)**：堆栈段寄存器。
   - 指向堆栈的段。

4. **ES (Extra Segment)**：附加段寄存器。
   - 为某些字符串操作提供一个附加的段选择。

8086还有一个特殊的寄存器：

1. **IP (Instruction Pointer)**：指令指针。
   - 与CS寄存器一起，CS:IP总是指向下一条要执行的指令。

以上列举的是8086微处理器的主要寄存器。这些寄存器为低级编程提供了大量的灵活性和功能。

## 标志位寄存器

下面是8086微处理器中标志位寄存器的总结，以及在DEBUG工具中显示的符号及其意义：

1. **CF (Carry Flag)** - 表示进位或借位
   - 值: 0 或 1
     - `0` (NC: No Carry) 表示没有进位
     - `1` (CY: Carry) 表示有进位
   
2. **PF (Parity Flag)** - 反映了结果字节中1的数量。
   - 值: 0 或 1
     - `0` (PO: Parity Odd) 表示1的数量为奇数
     - `1` (PE: Parity Even) 表示1的数量为偶数
3. **AF (Auxiliary Carry Flag)** - 在BCD（二进制编码十进制）运算中使用，当低4位产生进位或借位时设置。
   - 值: 0 或 1
     - `0` (NA: No Auxiliary Carry) 表示低4位没有进位
     - `1` (AC: Auxiliary Carry) 表示低4位产生了进位
4. **ZF (Zero Flag)** - 如果最后一个操作的结果为零，则设置ZF。
   - 值: 0 或 1
     - `0` (NZ: Not Zero) 表示结果不为零
     - `1` (ZR: Zero) 表示结果为零
5. **SF (Sign Flag)** - 反映了最后操作的结果的符号。
   - 值: 0 或 1
     - `0` (PL: Positive) 表示结果为正数或零
     - `1` (NG: Negative) 表示结果为负数
6. **TF (Trap Flag)** - 允许单步执行。
   - 值: 0 或 1
     - `0` (NT: No Trap) 表示TF未被设置
     - `1` (TR: Trap) 表示TF被设置
7. **IF (Interrupt Flag)** - 控制外部中断的响应。
   - 值: 0 或 1
     - `0` (DI: Disable Interrupts) 禁止中断
     - `1` (EI: Enable Interrupts) 允许中断
8. **DF (Direction Flag)** - 控制字符串操作的方向。
   - 值: 0 或 1
     - `0` (UP: Increment) 字符串操作地址自增
     - `1` (DN: Decrement) 字符串操作地址自减
9. **OF (Overflow Flag)** - 在有符号运算中，如果结果超出了有符号数值范围，则设置OF。
   - 值: 0 或 1
     - `0` (NV: No Overflow) 表示没有溢出
     - `1` (OV: Overflow) 表示有溢出

总的来说，ALU不是基于有符号和无符号数的概念来执行操作的。而是执行二进制运算，然后设置或清除相关标志以提供有关操作结果的信息。然后，程序员或编译器可以根据这些标志来解释和处理结果。

# Debug的使用

通过debug 能够查看寄存器的内容, 以及内存的内容, 并且指令执行跟踪

1. **A [address]**: Assemble
   - 用于在指定地址开始手动汇编代码。
   - 当你输入`A`然后按Enter，你可以开始输入汇编指令。
   - 使用空行结束汇编。
2. **D [range]**: Dump
   - 用于显示内存中的内容。
   - `D`后面可以跟一个地址范围，如`D 100 150`，表示显示从100到150的内存内容。
3. **E address [list]**: Enter
   - 用于修改指定地址的内存内容。
   - 例如，`E 100 90 91 92`会将地址100、101、102的内存值分别设为90、91、92。
   - 询问式更改 :  E 地址 空格继续,回车结束
4. **G [=address] [breakpoints]**: Go
   - 执行程序直到遇到指定的断点。
   - `G=100`表示从地址100开始执行。
5. **I port**: Input
   - 从指定的I/O端口读取值。
   - 例如，`I 60`会读取端口60的值。
6. **L range address**: Load
   - 从磁盘上的文件加载数据到指定地址的内存。
7. **N [filename]**: Name
   - 指定一个文件名，用于后续的读/写操作。
8. **R [register]**: Register
   - 查看或修改CPU寄存器的值。
   - 输入`R`会显示所有寄存器的值。`R AX`会显示AX寄存器的值，并允许你修改它。
9. **T [=address] [count]**: Trace
   - 单步执行指令。
   - `T=100 5`表示从地址100开始执行，并执行5条指令。
10. **U [range]**: Unassemble
    * 将指定内存地址的机器代码反汇编为汇编语言。
    * `U 100 150`表示将从100到150的地址反汇编。
11. **Q**: Quit
    * 退出DEBUG。

# 指令

* loop   相当于c语言的do while   执行的时候  先将cx的值减一,  然后判断是否为0
* inc  自增运算

# 补充

## CMOS RAM 

访问的时候直接使用这个数就行,   比如 0,2,4,6,8,  拿出来的数据都是一个字节

- 00h: 存储秒信息
- 02h: 存储分钟信息
- 04h: 存储小时信息
- 06h: 存储一周中的某一天的信息
- 07h: 存储月中的某一天的信息
- 08h: 存储月份信息
- 09h: 存储年份信息
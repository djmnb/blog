---
title: 计算机组成原理
date: 2023-6-27
tags: 
  - 计算机组成原理
  - 需要复习
---

# 计算机系统概述

## 计算机系统层次结构

### 计算机系统的组成

硬件系统+软件系统,   硬件是指有形的物理设备, 软件是指硬件上运行的程序和数据

### 计算机组成和计算机体系结构

计算机组成（Computer Organization）和计算机体系结构（Computer Architecture）是两个相关但又有所区别的领域。它们都关注计算机系统的设计，但从不同的角度。以下是这两者的主要差异：

1. **定义与焦点**：
   - **计算机体系结构**：关注系统的高层设计，如指令集、数据类型、寻址模式和计算机的功能抽象。简而言之，它是描述硬件和软件如何交互以及如何实现功能的接口和规范。
   - **计算机组成**：更注重硬件组件的具体实现和组织，如数据路径、控制逻辑、内存组织、输入/输出处理和流水线设计等。

2. **抽象层级**：
   - **计算机体系结构**：在更高的抽象层级。它定义了指令集以及如何进行高级运算，但不涉及具体如何在硬件上实现这些运算。
   - **计算机组成**：在较低的抽象层级。它关注如何使用电子部件和逻辑来实现体系结构中定义的功能。

3. **应用领域**：
   - **计算机体系结构**：对于编译器设计师、操作系统开发者和应用程序开发者来说，理解体系结构是非常重要的，因为他们需要确保他们的软件与给定的体系结构兼容。
   - **计算机组成**：对于硬件设计师和电子工程师来说，理解计算机组成是关键的，因为他们需要构建和组织硬件来满足体系结构的要求。

4. **示例**：
   - **计算机体系结构**：定义一台机器应该有哪些指令（例如，加法、乘法、加载、存储等）以及这些指令应该如何工作。
   - **计算机组成**：描述如何在硬件中实现这些指令，例如，为了实现加法指令，我们可能需要一个加法器、数据寄存器和其他控制逻辑。

总之，计算机体系结构关注“设计的是什么”，而计算机组成关注“如何实现这个设计”。两者紧密相关，但各自关注不同的设计和实现细节。

## 概念

* **存储元件**用来存储一位二进制代码,   **存储单元**包含若干个存储元件,  它能够包含一连串二进制代码,  这串二进制代码被称为**存储字**,  位数称为**存储字长**, 存储字长一般是一个字节或者是字节的偶数倍
* 机器字长(简称为字长)  是指一次整数运算能够处理的位数, 通常等于运算器位数,  



## 做题总结

* CPU执行时间 = 总指令时间周期数/主频  = 总指令时间周期数*时钟周期 = cpi * 指令数量 / 主频
* MIPS = 指令条数 / (执行时间 * 10 ^ 6) = x/(x\*CPI\*T * 10^6 ) = 主频 / (CPI*10^6) 
* (M,G,T,P,E,Z)FLOPS  每秒执行浮点数次数   M = 10^6 G = 10^9 T = 10^12 P = 10^15 E = 10^18 Z = 10^21

# 数据的表示和运算

## 数制与编码

### 采用二进制编码原因

计算机采用二进制编码有多种原因，其中最主要的是基于实际硬件实现的便利性和效率。以下是使用二进制的主要原因：

1. **简化硬件设计**：二进制只有两个状态：0 和 1，这与电子开关的基本工作原理相匹配，即开（ON）或关（OFF）。使用二进制编码可以轻松地用这些开关状态表示信息。例如，一个开关处于关闭状态可以表示0，而开启状态可以表示1。

2. **可靠性**：由于只有两种状态，二进制系统在处理噪声或其他干扰时更加鲁棒。例如，一个模拟系统可能受到细微的电压变化的影响，而二进制系统只需区分两种状态，因此更能够容忍小的误差或干扰。

3. **逻辑运算**：基于二进制的电子逻辑门（如AND、OR和NOT门）的设计和实现相对简单。这些逻辑门是计算机运行的基础。

4. **简化算术运算**：在二进制下，算术运算（如加法和乘法）可以通过简单的位操作实现，这在硬件上更易于实现。

5. **存储和传输**：二进制编码使得信息的存储和传输更加一致和简单。不论是处理文本、图像、音频还是视频，所有信息最终都可以转换为二进制形式并通过相同的基础硬件进行处理。

6. **历史和技术进展**：早期的计算机和计算机设备（如继电器和真空管）更容易以二进制方式工作。随着技术的进步，这种方法已经被证明是非常有效的，因此被继续沿用。

尽管二进制是最常用的编码方式，但在特定的应用和技术中，也有使用其他编码系统（如三进制、四进制等）的尝试。然而，由于上述原因，二进制已经成为了主流的选择。

### 进制转换

进制转换是计算机科学中的基础概念，尤其在考研408中也是经常被考察的内容。以下是常用的进制转换方法，包括整数和小数部分：

1. **二进制与十进制之间的转换**：
   - **整数部分**：
     - 从二进制转为十进制：按权展开，即从最低位开始，每一位的值乘以2的相应次方，然后求和。
     - 从十进制转为二进制：通过连续除以2并取余数的方法。**除基取余法**
   - **小数部分**：
     - 从二进制转为十进制：从小数点后的第一位开始，每一位的值乘以2的相应负次方，然后求和。
     - 从十进制转为二进制：通过连续乘以2并取整数部分的方法。**乘积取整法**

2. **二进制与八进制之间的转换**：
   - **整数部分**：每三位二进制数对应一位八进制数。
   - **小数部分**：同样，每三位二进制小数对应一位八进制小数。

3. **二进制与十六进制之间的转换**：
   - **整数部分**：每四位二进制数对应一位十六进制数。
   - **小数部分**：同样，每四位二进制小数对应一位十六进制小数。

4. **十进制与八进制、十六进制之间的转换**：
   - 通常先将十进制数转为二进制，然后再从二进制转为八进制或十六进制。

注意：在进行进制转换时，尤其是涉及小数部分，可能会遇到无法精确转换的情况，这时通常会取一个近似值。

在考研408的复习中，掌握这些基本的进制转换方法是非常重要的，因为它们是很多计算机科学概念的基础。

### 真值和机器数

1. **真值**：
   - 真值是一个数学上的概念，表示数的实际值，包括它的正负。(也就是带有"+","-"的数)
   - 例如，+5的真值是+5，-5的真值是-5。
2. **机器数**：
   - 机器数是计算机中用来表示一个数的二进制形式。对于正数，其真值和机器数是相同的；但对于负数，机器数是其补码形式。(使用数字代替正负号)
   - 在大多数现代计算机系统中，负数的表示采用的是“二进制补码”形式。这意味着负数的机器数是其绝对值的二进制反码加1得到的。
   - 例如，假设我们要在一个8位的系统中表示数字-5：
     1. +5的二进制形式是：0101
     2. 取反得到：1010
     3. 加1得到：1011 因此，-5的机器数是1011。

### 原码,反码,补码,移码

当我们在计算机中表示和处理整数，特别是负整数时，就会涉及到原码、反码、补码和移码这些表示方法。以下是这些概念的总结：

1. **原码**：
   - 原码是最直观的二进制表示方法。最高位是符号位：0表示正数，1表示负数。其余位表示该数的绝对值。
   - 例如：+7的原码为：0111，-7的原码为：1111（假设我们使用4位表示）。

2. **反码**：
   - 正数的反码与其原码相同。
   - 负数的反码是保持符号位不变，然后对原码的数值部分取反。
   - 例如：+7的反码为：0111，-7的反码为：1000。

3. **补码**：
   - 正数的补码与其原码相同。
   - 负数的补码是其反码加1。
   - 例如：+7的补码为：0111，-7的补码为：1001。
   - 补码是现代计算机中最常用的表示方法，因为它使得加法和减法运算更为简单。

4. **移码**：
   - 移码常用于浮点数的指数部分。它是通过将原码加上一个固定的偏移量（通常是2的(n-1)次方，其中n是位数）来得到的。
   - 对于4位表示，偏移量是2^3 = 8。所以，+7的移码是：0111 + 1000 = 1111，-7的移码是：1111 + 1000 = 0111。
   - 移码的主要优点是它可以使得负数的排序和正数相同。



## 运算

### 移位运算

* 逻辑移位
* 算数移位
* 循环移位

### 加减运算

* 原码加减法(了解即可)
* 补码加减法

溢出方法判别  两个相同符号位运算数的结果符号位不同 就是溢出

* 一位符号法:  两种情况  1 1 0  和 0 0 1  所以表达式为 V = $AB\overline{S} + \overline{A} \overline{B} S$
* 双符号法:  只有两个符号位不同的时候才算溢出  1 0 代表负溢出  0 1 代表正溢出  1 1 代表负数不溢出  0 0 代表正数不溢出
* 符号进位与最高位进位判别法 (做异或操作, 0 代表不溢出 1 代表溢出)  

**无论采用什么方法判断溢出,   存储的时候都是存放一位符号位,  只是在运算的时候,才把符号位的值同时放到ALU中(因为一个正确的数, 双符号位相同), 所以也就是说只在ALU中采用双符号位**

### 乘除运算

#### 原码一位乘法

符号位和数值为分开计算   乘积符号位由符号位运算得出  数值位由数值绝对值计算得出  

这个过程其实就是累加的过程

1. 部分积和被乘数在计算过程中采用双符号位,部分积初始值为0, 部分积最终存放的是高位数值
2. 如果当前乘数最低位为1, 则部分积加上被被乘数,   然后部分积和乘数都**逻辑右移一位** ( 部分积右移 溢出的是低位部分积)
3. 重复步骤2  n次
4. 将最终部分积高位与低位合并的结果的符号位设置成 符号位异或的结果

**可以发现一共做n次加法 n次移动**



#### 补码一位乘法(Booth算法)

这个算法步骤中符号位是参与运算的, 而且运算数都是补码计算, 它和原码一位乘法累加过程相似, 但是每一步是加法还是减法是需要另外计算的

1. 部分积和被乘数在计算过程中采用双符号位,部分积初始值为0, 部分积最终存放的是高位数值
2. 乘数末尾新增一位0(不参与计算,用于确定是加被乘数还是减被乘数) 
3.  靠乘数最后两位选出部分积是加被乘数还是减被乘数, 1 1 和 0 0 代表 + 0 ,  1 0 代表 - 被乘数 , 0 1 代表 + 被乘数 
4. 将乘数 逻辑右移, 部分积 **算数右移一位**(溢出的是低位部分积)
5. 重复3,4步骤 n次
6. 最后将部分积  再进行一次3步骤  
7. 最终部分积高位与低位合并的结果 **就是计算结果的补码**

**可以发现一共做n+1次加法 n次移动**



> 我发现一个问题就是, 书上貌似都是小数乘法, 但是如果是整数乘法,我感觉这些乘法是不太对的 我觉得应该要左移被乘数然后和部分积相加,   或者说需要改一下第7步, 低位就是最终结果



#### 原码除法(不恢复余数法)

除法其实就是做减法

数值位计算过程

1. 取两个数的绝对值
2. 先将被除数的绝对值-除数绝对值 相当于 +除数绝对值的补码
3. 根据计算出来的值称为余数  如果是正数  商的最后一位为1  商和余数都左移一位  然后-除数绝对值,  如果是负数 商的最后一位为0  商和余数都左移一位  然后 + 除数绝对值  (**逻辑左移**)
4. 重复 3步骤 n 次  (最后一步得到余数后, 还要给商设置一次值,根据3的规则)
5. 如果最后的余数为负数, 需要再加上除数绝对值
6. 最后将符号位做异或运算当做商的符号位

#### 补码除法(加减交替法)

符号位与数值位一起参加运算

1. 如果被除数与除数同号就 - 除数, 异号就加上除数
2. 根据计算出来的值称为余数  如果与除数同号就  商的最后一位为1  商和余数都左移一位  然后-除数,  如果与除数异号就 商的最后一位为0  商和余数都左移一位  然后 + 除数  (**算数左移**)
3. 重复 2 步骤 n次( 最后一步得到余数后, 如果对商没有特殊要求,  最后一位置1 )



## 数据类型转换

### 有符号数与无符号数相互转换

二者在内存中的二进制表示方式还是相同,  但是解释方式不同

```c++
int a = -1;
unsigned int b = (unsigned int)a;  // b = 2^32-1
```

### 不同字长整数之间的转换

大字长向小字长转换 直接截取大字长低位给小字长

```c++
int a = (int)0b11000000000000000000000000000000; //-1073741824
short b = (short)a; // 0
```

小字长向大字长转换  将小字长数据放入到大字长低位,  高位用小字长符号位填充(如果小字长是无符号数就用0填充)

(char 类型就是8位无符号整数)



## 数据的存储与排列

### 大端小端存储

由于每个数据只会有一个内存地址, 如果是多字节数据接下来的连续若干个地址构成了这个数据,  这样就会涉及到排列问题

* 大端方式   从大大小排列  高位在前  低位在后   也就是高位在低地址, 低位在高地址
* 小端方式  从小到大排列  低位在前 高位在后  也就是低位在低地址 高位在高地址

如果地址从左到右依次增加,  那么大端方式的话 就相当于顺序存放一个数,   小端就相当于逆序**(字节内有序)**

```c++
int a = 0x01234567
// 01 23 45 67  大端
// 67 45 23 01  小端 
```

### 边界对齐方式存储

* 边界对齐方式能够使  半字数据和字数据都能各自存放在一个存储单元中, 不会分布在不同的存储单元中, 但是会浪费一定的空间, 优点是提高指令和数据的读写速度
* 边界不对齐方式  可以充分利用存储空间,   但是一个字或者半字数据会存放在不同的存储单元中, 这样读取一个字或者半字的指令或者数据的时候,需要多次访存

## 浮点数的表示与运算

> 浮点数就是小数点位置不固定的数,  这里的不固定不是指小数点会真正的移动,  而是指通过缩放数据, 让小数点逻辑移动

### 表示格式

符号位 阶码  尾数  

* 符号位取值 0 1 代表正负
* 阶码或者叫指数   用移码表示  这里还隐约包含了  基数  通常采用 2    阶码就反应了浮点数小数点实际位置
* 尾数的位数反应了精度  尾数部分通常用原码表示

### 浮点数的规格化

定义:  通过调整尾数和阶码的大小,  让非零浮点数的尾数部分最高位是一个有效值

规范化的尾数绝对值肯定满足   1/R <= |M| <= 1   R代表基数   M代表尾数值

### IEEE754标准

IEEE 754标准是一个定义浮点数算术的国际标准，广泛应用于计算机和数字系统中。以下是该标准的总结：

1. **基本组成**：
   - **符号位（Sign bit）**：决定浮点数的正负。0表示正数，1表示负数。
   - **指数（Exponent）**：表示浮点数的阶数。使用一个偏移（bias）格式来表示。2^(n-1) - 1
   - **尾数（Mantissa 或 Fraction）**：表示浮点数的有效数字。

2. **主要格式**：
   - **单精度（32位）**：
     - 符号位：1位
     - 指数：8位，偏移值为127   2^7 -1 
     - 尾数：23位
   - **双精度（64位）**：
     - 符号位：1位
     - 指数：11位，偏移值为1023   2^10 -1 
     - 尾数：52位

3. **特殊值**：
   - **零（0）**：有正零和负零，指数和尾数都为0。
   - **无穷（Infinity）**：正无穷和负无穷，指数为最大值，尾数为0。
   - **NaN（Not a Number）**：表示不是一个数的值，如0除以0的结果。指数为最大值，尾数不为0。

4. **规格化与非规格化数**：
   - **规格化数**：**尾数部分的隐含的最高位是1**。例如，对于单精度，它是1.xxxxx的形式。
   - **非规格化数**：当指数部分为全0时，表示的数是非规格化的，隐含的最高位是0。这允许表示接近于0的非常小的数。

5. **舍入模式**：
   IEEE 754标准定义了多种舍入模式，包括最近偶数舍入（默认模式）和向正无穷、向负无穷、向零舍入等。

6. **操作和异常**：
   标准定义了浮点数的基本操作（如加、减、乘、除等）以及可能的异常情况（如溢出、下溢、除以零等）和它们的处理方式。

IEEE 754标准为浮点数的表示和运算提供了一个统一和一致的框架，被广泛采用于现代计算机和数字系统中。理解这个标准的基本概念和特点对于计算机科学和工程领域是非常重要的。

### 浮点数的加减运算

对阶:  小阶通过尾数右移 阶码增加 像大阶对其   这样的话会舍弃掉有效位 产生误差影响精度

尾数求和:  将对阶后的尾数运算即可   运算后的尾数不一定是规格化的,  此后还需要规格化

舍入: 在对阶和尾数右规式, 为了保证运算精度, 一般将低位溢出的两位保留下来参加中间运算过程, 最后将运算结果舍入

常见舍入方法:

* 0舍1入法:  类似于四舍五入, 保留位的最高位为0则舍去  保留位的最高位为1 **尾数末位+1**   这样可能导致尾数溢出, 需要再一次右规   
* 恒置1法:  如果保留的两位中 存在一个1, 则**尾数末位设置为1**
* 截断法: 直接舍去

溢出判断:  浮点数的溢出判断是根据阶码来判断的,  如果阶码全0  则表示下溢出,  全1 则表示上溢出

## 浮点数和定点数的区别

浮点数和定点数是数字系统中两种不同的数值表示方法。它们各自有其优点和缺点，适用于不同的应用场景。以下是它们之间的主要区别：

1. **定义**：
   - **浮点数**：浮点数的表示方式类似于科学记数法，其中数值的小数点位置可以“浮动”。一个浮点数由符号位、指数和尾数三部分组成。
   - **定点数**：定点数的小数点位置是固定的。它由整数部分和小数部分组成，小数点的位置在表示中是固定不变的。

2. **表示范围和精度**：
   - **浮点数**：由于其指数的存在，浮点数可以表示非常大或非常小的数值，但精度可能会受到限制，特别是对于非常大或非常小的数值。
   - **定点数**：定点数的表示范围受到其整数和小数部分的位数的限制，但在其表示范围内，精度是固定的。

3. **计算复杂性**：
   - **浮点数**：浮点数的算术运算（如加、减、乘、除）相对复杂，需要专门的硬件支持，如浮点数算术单元（FPU）。
   - **定点数**：定点数的算术运算相对简单，可以在没有专门浮点硬件的系统上高效地执行。

4. **应用场景**：
   - **浮点数**：适用于需要处理大范围数值或高精度计算的应用，如科学计算、图形处理等。
   - **定点数**：常用于嵌入式系统、数字信号处理等领域，其中硬件资源可能有限，但需要快速、确定的计算性能。

5. **硬件和存储**：
   - **浮点数**：通常需要更多的硬件资源和存储空间来表示和处理。
   - **定点数**：通常更加紧凑，需要较少的硬件资源和存储空间。

6. **误差和精度**：
   - **浮点数**：可能会引入舍入误差，特别是在连续的算术运算中。
   - **定点数**：误差通常是固定的，但数值范围受到限制。

总的来说，浮点数和定点数都是数字系统中表示数值的方法，选择哪种方法取决于特定的应用需求、硬件资源和性能要求。



## 做题技巧

* 对于补码反码来说,  数值部分越大, 对应的真值也越大
* 对于正数来说, 反码,补码,原码是相同的, 只有移码不同,  而对于负数来说, 就都有可能不同了,   移码和补码只有符号位相反
* 对于并行加法器来说,  加法器没有区别,  只是进位的产生不再是串行产生了,  而是并行产生, 由一个CLA电路根据各位数值计算而来
* 对于减法运算来说,  低位进位都是1, 代表选用减法运算, 然后减少要取反+1
* 对于边界对齐的计算机来说, 一般按照机器字长来对齐, 不够的就用空白来填
* **对于IEEE754标准, 将其他数据转换为 浮点数的时候,  阶码一定要加上偏移值,   浮点数转换为其他数的时候, 阶码一定要减去偏移值**
* 浮点数变成定点数  尾数左移阶码表示数量    定点数变成浮点数  右移尾数   阶码增加

# 存储器系统

## 存储器的概述

### 存储器的分类

#### 按照作用层次分类

存储器按照作用层次可以分为几个不同的级别，每个级别都有其特定的性能特点、容量和成本。以下是按作用层次分类的存储器：

1. **寄存器（Registers）**：
   - **位置**：位于CPU内部。
   - **特点**：访问速度极快，但容量非常有限。
   - **用途**：存储即将被处理的指令、数据或地址。

2. **高速缓存（Cache Memory）**：
   - **位置**：位于CPU芯片上或接近CPU的位置。
   - **特点**：访问速度快，但容量相对有限且成本较高。
   - **用途**：暂存经常访问的数据和指令，减少CPU与主存之间的速度差异。

3. **主存储器（Main Memory，通常指RAM）**：
   - **位置**：位于CPU外部，通过内存总线与CPU连接。
   - **特点**：访问速度比高速缓存慢，但容量较大且成本较低。
   - **用途**：存储操作系统、应用程序和当前处理的数据。

4. **辅助存储器（Secondary Memory 或 Mass Storage）**：
   - **位置**：通常位于计算机的外部。
   - **特点**：访问速度比主存储器慢得多，但提供大量的存储空间，成本较低。
   - **用途**：长期存储数据、程序和信息。常见的辅助存储器包括硬盘、SSD、光盘和磁带。

5. **离线存储（Offline Storage）**：
   - **位置**：不直接连接到计算机系统。
   - **特点**：需要人工干预才能访问，通常用于备份或长期存储。
   - **用途**：数据备份、归档。例如，外部硬盘、光盘、磁带等。

这些存储器层次形成了一个存储器层次结构，从上到下，访问速度逐渐减慢，但容量逐渐增大，成本每位逐渐降低。这种层次结构的设计是为了平衡性能和成本，确保计算机系统能够高效地运行。

#### 按照存储介质

按照存储介质分类，存储器可以分为以下几种类型：

1. **半导体存储器**：
   - **特点**：基于半导体技术，如硅。
   - **例子**：
     - **RAM（Random Access Memory）**：
       - **SRAM（Static RAM）**：使用触发器作为存储单元，速度快，常用作CPU的高速缓存。
       - **DRAM（Dynamic RAM）**：使用电容作为存储单元，需要定期刷新，主要用作主存储器。
     - **ROM（Read-Only Memory）**：只读存储器，用于存储固定数据或程序。
     - **Flash Memory**：可以电擦写的非易失性存储器，常用于USB驱动器、SD卡和SSD。

2. **磁性存储器**：
   - **特点**：使用磁介质来存储数据。
   - **例子**：
     - **硬盘驱动器（HDD）**：使用磁盘片和读写头来存储和访问数据。
     - **磁带**：主要用于数据备份和长期存储。
     - **磁芯存储**：早期计算机中使用的存储技术，现已过时。

3. **光学存储器**：
   - **特点**：使用光介质和激光技术来存储数据。
   - **例子**：
     - **CD（Compact Disc）**
     - **DVD（Digital Versatile Disc）**
     - **Blu-ray Disc**

4. **机械存储器**：
   - **特点**：基于机械移动部件。
   - **例子**：早期的打孔卡和打孔纸带。

5. **固态驱动器（SSD）**：
   - **特点**：没有机械部件，基于闪存技术。
   - **例子**：现代的SSD驱动器，用于替代传统的硬盘驱动器，提供更快的读写速度。

6. **相变存储器**：
   - **特点**：使用材料的相变（从结晶态到非结晶态）来存储数据。
   - **例子**：某些特定的光盘技术和新型非易失性存储器。

7. **磁阻和自旋转移磁阻存储器**：
   - **特点**：基于磁阻效应或自旋转移磁阻效应。
   - **例子**：MRAM（磁阻随机存取存储器）。

这些存储介质类型涵盖了从早期计算机技术到现代高速存储解决方案的各种技术。选择哪种存储介质取决于特定的应用需求、性能要求和成本考虑。

#### 按照存储方式分类

按照访问方式分类，存储器可以分为以下几种类型：

1. **随机访问存储器（Random Access Memory, RAM）**：
   - **特点**：可以在任意顺序下访问任何地址的存储位置，每次访问的时间基本相同。
   - **例子**：DRAM（Dynamic RAM）、SRAM（Static RAM）。

2. **只读存储器（Read Only Memory, ROM）**：
   - **特点**：数据被预先写入，通常在生产过程中，并且在正常操作中不可更改。
   - **例子**：PROM（Programmable ROM）、EPROM（Erasable PROM）、EEPROM（Electrically Erasable PROM）。

3. **顺序访问存储器（Sequential Access Memory）**：
   - **特点**：数据只能按照一定的顺序访问，不像RAM那样可以随机访问。
   - **例子**：磁带是典型的顺序访问存储器。

4. **直接访问存储器（Direct Access Memory）**：
   - **特点**：可以直接访问到存储器的某个位置，但访问时间可能会根据位置的不同而有所变化。(先找到一个局部位置,  然后局部位置顺序访问)
   - **例子**：硬盘驱动器（HDD）。

5. **关联存储器（Associative Memory 或 Content-Addressable Memory, CAM）**：
   - **特点**：基于数据内容而不是地址来进行搜索。当提供一个数据片段或关键字时，关联存储器可以快速找到与之匹配的完整记录。
   - **例子**：某些高速缓存实现和路由器中的查找表。

6. **寄存器存储器（Register Memory）**：
   - **特点**：位于CPU内部，为CPU提供快速访问的小块存储空间。
   - **例子**：指令寄存器、累加器、数据寄存器等。

这些分类基于存储器的访问机制和特性。在实际应用中，不同的访问方式适用于不同的用途和性能要求。

#### 按信息可保存性分类

按照信息的可保存性分类，存储器可以分为以下几种类型：

1. **易失性存储器（Volatile Memory）**：
   - **特点**：当电源关闭或断电时，存储在其中的数据会丢失。
   - **例子**：
     - **RAM**：包括DRAM（Dynamic RAM）和SRAM（Static RAM）。

2. **非易失性存储器（Non-Volatile Memory）**：
   - **特点**：即使在断电或关闭电源后，数据仍然可以被保存。
   - **例子**：
     - **ROM（Read-Only Memory）**：包括PROM、EPROM、EEPROM等。
     - **Flash Memory**：如USB闪存驱动器、SSD和SD卡。
     - **硬盘驱动器（HDD）**
     - **光盘**：如CD、DVD和Blu-ray Disc。
     - **磁带**

3. **半易失性存储器（Semi-Volatile Memory）**：
   - **特点**：介于易失性和非易失性存储器之间。在正常情况下，它表现得像非易失性存储器，但在某些条件下（如高温或特定的电子操作）数据可能会丢失。
   - **例子**：某些特定的Flash Memory或磁阻存储器（MRAM）可能被认为是半易失性的，尽管这种分类不太常见。

这些分类基于存储器保存数据的能力，特别是在断电或关闭电源时。在实际应用中，选择哪种类型的存储器取决于特定的数据保存需求和应用场景。

### 存储器性能指标

主要有三个指标: 存储容量, 单位成本, 存储速度

1. 存储容量 = 存储字数 * 存储字长   字数代表存储空间大小   字长代表一次存取操作数据量
2. 单位成本 = 总成本 / 总容量
3. 存储速度:  数据传输率 = 数据宽度 / 存储周期
   * **存取时间**:    是从发出读取或写入请求到存储器响应并提供所需数据或确认写入完成的时间。简单地说，它是从请求开始到数据可用（对于读操作）或数据被成功写入（对于写操作）的时间。
   * **存取周期**: 是连续两次存储访问操作之间所需的最小时间间隔。它包括了存取时间以及为**下一个访问操作预留的额外时间**。这个额外的时间通常是为了确保**存储器内部的操作完成，如数据线和地址线的稳定**。

### 多级层次存储系统

多级层次存储系统主要是为了解决  容量大 速度快 成本低 三个相互制约的矛盾  

多级层次存储系统是计算机存储的一个设计概念，它通过组合不同性能和成本的存储技术，旨在提供接近最快存储速度的性能，同时保持较低的总体成本。这种系统的核心思想是：经常访问的数据应该存储在快速但昂贵的存储介质中，而不经常访问的数据则存储在慢速但便宜的存储介质中。

以下是多级层次存储系统的主要层次：

1. **寄存器**：
   - **位置**：CPU内部。
   - **特点**：极高的访问速度，但容量非常有限。
   - **用途**：存储即将处理的指令和数据。

2. **高速缓存（Cache）**：
   - **位置**：位于CPU内部或接近CPU。
   - **特点**：高速访问，但容量有限且成本较高。
   - **用途**：存储经常访问的数据和指令，减少CPU与主存之间的速度差异。

3. **主存储器（RAM）**：
   - **位置**：位于CPU外部。
   - **特点**：访问速度较快，容量大于Cache但小于辅助存储器，成本适中。
   - **用途**：存储操作系统、应用程序和正在处理的数据。

4. **辅助存储器（如硬盘、SSD）**：
   - **位置**：通常位于计算机的外部。
   - **特点**：较大的存储容量，访问速度慢于RAM但快于离线存储，成本较低。
   - **用途**：长期存储数据和程序。

5. **离线存储/备份存储（如磁带、光盘）**：
   - **位置**：可能需要人工干预才能访问。
   - **特点**：巨大的存储容量，但访问速度最慢，成本最低。
   - **用途**：数据备份、归档和长期存储。

在多级层次存储系统中，数据会根据其访问频率和重要性在不同的层次之间移动。例如，当CPU需要某个数据项时，它首先会在寄存器或高速缓存中查找。如果没有找到，它会继续在RAM中查找，然后是硬盘或SSD，以此类推。

这种层次结构的设计是为了平衡性能和成本，确保计算机系统能够以最低的成本提供最高的性能。

cache - 主存层 数据调动  是由 硬件自动完成, 对任何程序员透明(也就是不能也不需要干涉)   主存-辅存层之间的数据调用是硬件+操作系统共同完成,  所以对应用程序员是透明的



## 主存储器

主存储器由DRAM 实现  cache层则由 SRAM实现,   DRAM的每位价格是低于SRAM的,速度也慢,  价格差异主要在SRAM集成度低,需要多个元器件, 需要更多的硅, 而DRAM里面就一个电容和晶体管

### SRAM 和 DRAM

#### SRAM

SRAM（Static Random Access Memory）是一种随机访问存储器，与DRAM相比，它有其独特的特点和应用。以下是对SRAM的总结：

1. **基本结构**：
   - SRAM单元通常由**六个晶体管**组成，而不是像DRAM那样由一个电容和一个晶体管组成。

2. **静态性质**：
   - SRAM的“静态”名称意味着它不需要定期刷新来保持其内容。**只要电源供应持续，数据就会保持不变**。

3. **速度**：
   - SRAM比DRAM快。这是因为SRAM不需要刷新，并且其内部结构允许更快速的数据访问。

4. **成本与密度**：
   - 由于SRAM单元需要更多的晶体管，它的密度低于DRAM，这也使得其成本相对较高。

5. **功耗**：
   - 在待机模式下，SRAM通常消耗的功率比DRAM少，但在活动模式下，由于不需要刷新，SRAM的功率消耗可能较低。

6. **应用**：
   - 由于其速度优势，SRAM通常用作CPU的高速缓存（如L1、L2或L3缓存）。
   - 它也用于其他需要快速访问的应用，如实时系统的数据存储。

7. **稳定性**：
   - SRAM比DRAM更稳定，因为它不依赖于电容来存储数据，因此不受电容放电的影响。

8. **物理大小**：
   - 由于SRAM单元需要更多的晶体管，它通常比DRAM大，这限制了它在某些高密度应用中的使用。

总的来说，SRAM由于其速度和稳定性优势，主要用于高速缓存和其他需要快速数据访问的应用，但其高成本和低密度使其不适合作为主存储器。

#### DRAM

DRAM（Dynamic Random Access Memory）是一种随机访问存储器，广泛用于计算机和其他电子设备的主存储器。以下是对DRAM的总结：

1. **基本结构**：
   - DRAM单元通常由一个电容和一个晶体管组成。电容存储数据（充电表示1，放电表示0），而晶体管作为控制开关，决定是否访问电容。

2. **动态性质**：
   - DRAM的“动态”名称来源于其需要定期刷新来保持其内容。电容会随时间自然放电，因此需要定期重新充电以保持存储的数据。

3. **速度**：
   - DRAM的访问速度比SRAM慢，部分原因是由于刷新操作。但与硬盘和其他非易失性存储相比，其速度仍然非常快。

4. **成本与密度**：
   - 由于DRAM单元的结构简单（只需要一个电容和一个晶体管），它具有较高的密度，这使得其成本相对较低，尤其是在大容量配置中。

5. **功耗**：
   - DRAM在刷新时会消耗功率，但其功率需求通常低于SRAM，尤其是在高性能操作中。

6. **应用**：
   - DRAM是现代计算机、游戏机、服务器和许多其他设备的主要主存储器形式。
   - 它也被用于图形卡中，称为GDDR（与标准DRAM有所不同，特别优化用于图形数据）。

7. **稳定性**：
   - 由于需要定期刷新，DRAM在无电情况下不能长时间保持数据。

8. **物理大小**：
   - DRAM的物理尺寸较小，这使得它能够在有限的空间内提供大量的存储容量。

总的来说，DRAM由于其成本效益、高密度和合理的速度，成为了现代电子设备中的主要存储技术。但其需要定期刷新的特性也为系统设计带来了额外的考虑。

刷新方式

1. **集中刷新（Concentrated Refresh）**：
   - **描述**：在一个短时间内连续进行所有必要的刷新操作，然后在较长的时间段内不进行任何刷新。这意味着在一个特定的时间窗口内，DRAM会连续地进行多次刷新操作。
   - **优点**：在刷新之外的时间，DRAM完全可用于正常的读/写操作，不会受到刷新的干扰。
   - **缺点**：在集中刷新期间，DRAM可能无法响应正常的读/写请求，从而导致性能下降。 **存在死时间**
2. **分散刷新（Distributed Refresh）**：
   - **描述**：刷新操作在时间上均匀分布，而不是集中在一个短时间内。这意味着在一个给定的时间段内，刷新操作会定期发生，但每次只刷新一小部分。(**前半段时间正常读写, 后半段用来刷新, 这样整个系统的存取周期增长了)**  
   - **优点**：由于刷新操作被分散，DRAM大部分时间都可以响应正常的读/写请求，从而减少了刷新对性能的影响。 **不存在死时间**
   - **缺点**：需要更复杂的控制逻辑来确保在整个操作期间都进行了足够的刷新。
3. **异步刷新（Asynchronous Refresh）**：
   - **描述**：刷新操作与正常的读/写操作完全独立，可以在任何时间进行。这意味着刷新操作不必等待当前的读/写操作完成，反之亦然。(**内部有一个逻辑电路, 每隔一段时间发起一次刷新请求**)
   - **优点**：提供了极大的灵活性，允许DRAM在高负载条件下优化性能。**降低了死时间**
   - **缺点**：可能需要更复杂的控制逻辑和更高的带宽来同时处理读/写和刷新操作。

**刷新操作对CPU是透明的,**  刷新的单位是行, 由芯片内部自动生成行地址, 而且刷新操作不需要选片

### 主存储器的基本组成

存储元 -> 存储单元 -> 存储体

地址单元是指 具有相同地址的存储单元构成的一个单位   可以按照字节编址, 也可以按照字编址. 现代计算机基本使用字节编址

### 多模块存储器

多模块存储器是一种空间并行技术, 利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率

#### 单体多字存储器

单体多字存储器是一种存储器结构，其中一个存储体内部包含多个字（数据单元）。这种结构的主要目的是提高数据传输的带宽和效率。

在单体多字存储器中，每个存储地址可以访问一个数据块，而不仅仅是一个单独的数据字。例如，如果我们说一个存储器是“4字存储器”，那么每个存储地址可能会映射到4个连续的数据字。

**特点**：

1. **并行性**：在单体多字存储器中，尽管数据是顺序存储的，但多个数据字可以**并行地被读取或写入**。例如，如果一个存储器配置为4字存储器，那么在一个时钟周期内，它可能能够并行地读取或写入4个数据字。这与传统的存储器不同，后者可能在同一个时钟周期内只能访问一个数据字。( **访问的字会放到缓存中,如果没有全部处理的话,下一次就是访问缓存, 而不是访问内存**)  

2. **高带宽**：由于每次访问可以获取多个数据字，因此数据的传输率得到提高。

3. **连续存储**：在物理存储中，相关的数据字通常是连续存储的，这有助于提高顺序访问的效率。

4. **复杂的控制逻辑**：由于每个地址映射到多个数据字，所以控制逻辑可能会变得更复杂，特别是在数据需要被分散到不同的位置或从多个位置收集时。

**应用**：

单体多字存储器在需要高带宽和高数据传输率的应用中特别有用，例如图形处理或某些高性能计算任务。

然而，这种存储器结构并不总是最优的选择，因为它可能会增加成本和复杂性，尤其是在不需要连续高带宽的应用中。在选择存储器结构时，设计者需要权衡这些优缺点。

#### 多体并行存储器

多体并行存储器由 多体模块组成, 每个模块都有相同的容量和存取速度, 各个模块又有独立的读写控制电路, 地址寄存器和数据寄存器,  他们既能并行工作, 又能交叉工作

高位交叉编址:   高位地址决定模块号 低位地址决定块内地址    如果是顺序访问主存块的话, 我们会发现 基本都是在同一个模块里面访问,这个跟普通的存储器没有区别, 也就是说没有利用到并行的优点   (顺序方式)

低位交叉编址:  低位地址决定模块号 高位地址决定块内地址  如果是顺序访问主存块的话,  我们会发现它基本会依次访问各个模块, 这样就能利用到并行的优点, 在上一个模块的还在等待可以被访问的时候,  我们可以访问下一个模块. 采用这种方式编址的存储器称为  **交叉存储器**

假设各个模块的存取周期为 T, 总线的传输周期为r  如果要满足流水线方式存取, 那就需要  **模块数 m >= T/r**   证明:  在第一个模块被访问后  需要T时间后才能访问,  那么这个时间内我们需要访问其他模块,  也就是  (m-1) * r >= T-r.     所以连续访问m个字需要的时间为  T+(m-1)*r  (书上是这么写) ,  但是还有另外一种说法,  就是在一定时间t内能够访问多少个字,  那就是  t/r个字

## 主存与CPU的连接

### 主存的扩展

### 存储芯片的地址分配与片选



## 外部存储器

### 磁盘存储器

### 固态硬盘

基于闪存的技术,和U盘没有本质区别,  本质上还是一个ROM

## 高速缓冲区





## 做题技巧

1.  DRAM的芯片容量较大,  地址位数多,  为了减少芯片地址引脚数, 通常采用地址引脚复用技术,  行列地址使用相同的引脚先后两次输入, 这样可以减少一半的引脚数
2.  关于DRAM 与 SRAM 最小引脚数问题 一般涉及几个方面
   * **片选线（Chip Select, CS）**：用于选择特定的存储器芯片。在多芯片配置中，片选线可以帮助确定哪个芯片被选中进行读写操作。
   * **读写控制线**：
     - **R/W**：这是一个双向控制线，用于指示是读操作还是写操作。对于某些存储器，读写控制可能会分为两个单独的线（例如，一个读控制线和一个写控制线）。
   * **地址线**：
     - **DRAM**：由于DRAM通常使用多路复用技术，所以它的地址线数量通常是总地址位数的一半。例如，一个有16M个存储位置的DRAM可能只需要11根地址线（因为2^11 = 2048，而2048x2048 = 16M）。
     - **SRAM**：SRAM不使用多路复用，所以它的地址线数量等于其地址位数。
   * **数据线**：数据线的数量通常与存储器的数据宽度相匹配。例如，8位宽的存储器会有8条数据线。
   * **电源和地线**：这些线为存储器提供电源。通常有VCC（或VDD）和GND。
   * **输出使能线（Output Enable, OE）**：在某些设计中，这个线用于控制数据线上的输出。当OE被激活时，存储器的输出被放到数据线上。
   * **其他控制线**：根据特定的存储器设计和应用，可能还有其他的控制线，如刷新控制线（特别是对于DRAM）。
   * **行选通线（Row Address Strobe, RAS）**：当RAS信号被激活时，它告诉DRAM接下来的地址信息是行地址。这个行地址确定了DRAM中的一个特定行。
   * **列选通线（Column Address Strobe, CAS）**：当CAS信号被激活时，它告诉DRAM接下来的地址信息是列地址。这个列地址与之前的行地址一起确定了DRAM中的一个特定单元。(**对于DRAM地址复用来说, 我们可以使用行列选通线与片选线共用**)
3.  ROM 只读存储器具有随机访问的功能,  但是他不是随机访问存储器RAM
4.  DRAM一次完整的刷新占用一个存储周期,  相当于读出来之后立即写回,**其实就相当于一次访存**   
5.  **切莫粗心大意, 对于  8K 这种 一定不要写成了  2^18  它是 2^13**

# 指令系统

# 中央处理器(CPU)

# 总线

# 输入输出(I/O)系统

# 额外补充



## 组合逻辑电路和时序逻辑电路

组合逻辑电路和时序逻辑电路是数字逻辑设计中的两个基本概念。它们的主要区别在于是否涉及时间或时序的概念。

1. **组合逻辑电路**：

   - **定义**：组合逻辑电路的输出仅仅依赖于当前的输入值，而与先前的输入或状态无关。

   - 特点

     ：

     - 没有记忆功能。
     - 任何时候，相同的输入都会产生相同的输出。

   - **常见元件**：基本逻辑门（如AND、OR、NOT）、多路复用器、解码器、编码器等。

   - **应用**：算术逻辑单元（ALU）、解码器、编码器等。

2. **时序逻辑电路**：

   - **定义**：时序逻辑电路的输出不仅依赖于当前的输入，还依赖于先前的输入或状态。这意味着它具有记忆功能。

   - 特点

     ：

     - 有记忆功能，能够存储信息。
     - 输出取决于当前输入和先前的状态。

   - **常见元件**：触发器（如D触发器、JK触发器、T触发器）、计数器、寄存器、时钟等。

   - **应用**：存储元件、计数器、状态机等。

**总结**：

- 组合逻辑电路是“无记忆”的，其输出完全由当前输入决定。
- 时序逻辑电路具有“记忆”功能，其输出由当前输入和先前的状态共同决定。
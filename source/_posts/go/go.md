---
title: go总结
date: 2022/12/9
tags: Go
---

## 环境搭建

Go设置国内镜像源

```go
go env -w GOPROXY=https://goproxy.cn,direct
```



## 基础教程

go.mod 是用来管理我们引入模块的信息,里面记录了我们当前模块的模块名,以及需要的模块的信息

go mod init 名字  用来创建一个模块

go mod tydy 加载模块(本地,或者远程)

init 函数会最先执行,早于main函数

go中**{**不能单独一行

一行代表一个语句结束,如果要多个语句写一起,就必须使用;分隔,但是并不推荐这样做

### 数据类型

注意一下不同的数据类型就行了

* *int   这个和c语言不同哦,c语言是int* ,不过使用起来是一样的,只是声明的时候不同
* 函数类型 声明的时候,是可以直接用变量接收一个函数的哦

### 变量声明方式  

方式1  var 名字1,名字2 .... type (没有赋值,默认值代替)

方式二 var 名字1,名字2 类型 = 值1,值2  (值类型必须一致

方式三 var 名字 1,名字2= 值1,值2  (根据类型推断)

方式四(局部变量才可以用) 名字1,名字2:=值  相当于  var 名字1 type,var 名字2 type   名字1 = 值1 名字2 = 值2   (这么写方便啊,少写很多东西,哈哈哈哈)  这种方式只能用在函数内部,全局是不可以的,因为函数外面的全局只能写声明然后直接赋值,而不能声明后,再单独写个语句赋值

方式五  

```
var(
a,b
)
```

比如说

```go
var a = 10; //可行
var b int;
b = 10  //不可行
func main(){

}
```

go 语言中如果声明变量而不使用的话,则会报错,我们可以使用 _ = 变量 , 消除这个报错, _ 是一个只写变量,而不能读它, 有人就说了,这不是搞笑么,我不声明不就行了嘛, 可是有时候,你不得不声明,比如一个函数可以返回多个值,你只想要其中某一部分的值,但是那些不要的值你也得接收啊,所有_就派上用场了(全局变量可以只声明而不使用哦)

### 常量声明方式

方式一  const name1,name2 =val1,val2   (必须为每个变量赋值)

方式二 

```go
const(
    a = 1
    b
    c
    d
)
// 这种方式的话 如果不赋值,默认跟前一个"赋值方式一样"所有第一个必须赋值
// iota 特殊常量
// 在这种常量赋值的方法中,iota会被赋值为0,每增加一个常量,iota的值就加一,我们是不能自己去修改的哦
```

常量可以只声明而不使用的哦



### 运算符

go的运算符跟c++ 差不多,就简单说点不同的地方

> go  不支持 三目运算符哦

go 提倡的是 一个语句占一行,像 a++ 这种已经就是一个语句了,所以我们这种写法会报错  sum += a++  这个相当于两条语句,所有go是不允许的

### 流程控制语句

#### if 

```go
// 1
if ( 逻辑表达式){

}
// 2
if 逻辑表达式{
}
```



#### swtich

这个与c语言还是有点区别的

```go
//只要进入了case的分支,就不会再进入其他case分支了(这里是与c语言不同的),不过可以通过fallthrough 强制执行后面分支
switch var1 {
    case val1:
        ...
    case val2:
        ...
    default:
        ...
}
```

#### for

```
//与c语言的一样但是不能加()
for a:=1;a<=10;a++{

}
//与c的while差不多
a := true
for a{

}
// 与c的for(;;)一样
for{}
// 与 c++的for(int i : num) 差不多
for k,v = range map
```

go 里面没有while语句哦,for可以替代它的

### 函数

这个基本是所有语言都有的,只不过格式不同罢了

```go
func funcname (parameter list) return_types {}
```

go的函数可以返回多个值,每个值的类型都必须声明好

这个参数是可以传递函数的哦,其实也没什么奇怪得啦,c语言里面传递函数是通过指针传递,用起来比较麻烦,但是go里面可以直接传递

#### 闭包

go里面的函数还可以闭包哦,就是一个函数的返回值也是一个函数,闭包的优势就在与,返回来的函数直接使用产生它的函数的变量,举个列子

求素数的列子

```go
package main

func getPrimeFunc() func() int {
	var i = 1
	return func() int {
		for {
			i++
			j := 2
			for ; j <= i/j; j++ {
				if i%j == 0 {
					break
				}
			}
			if j > i/j {
				return i
			}

		}

	}
}
func main() {
	var getPrime = getPrimeFunc()
	println(getPrime())
	println(getPrime())
	println(getPrime())
	println(getPrime())

}
```

使用闭包,我们可以使的逻辑变的清晰,

#### 方法

方法与函数的声明有点区别,前面加了接受者类型

```
func (variable_name variable_data_type) funcname(paremeter list) (return_type){}
```

### 变量作用域

* 函数类定义的是局部变量,只能在函数内使用,所谓的函数内是指当前函数,以及这个函数产生的匿名函数也能够使用
* 函数外定义的是全局函数
* 函数定义中的变量是形参变量

### 数组

定义

```go
var nums [10] int  //一维 
var nums [10][10] int //二维  go的二维数组跟java很类似,第二维可以长度不一样,c++不行
```

初始化

```go
var nums = [10] int{1,2,3} //定义的时候初始化
var nums = [...] int{1,2,3,4} //自动推断数组长度
nums := [10] int{1,2,3} //这种就自然不用说了
nums[0] = 1 //定义完后赋值

//go的数组跟java的很像,就是一个引用类型罢了,不过需要注意的是,java数组的引用是不需要长度一样的,而go是严格要求引用长度得一样
nums := [10] int{1,2,3}
nums = [10] int {4,5,6} //ok
nums = [3] int {4,5,6} // no
```

### 指针

看到这个我就不陌生了,c和c++里面再熟悉不过了

定义

```go
var point *int
//赋值
point = &a
//使用
*point
```

go里面的空指针是nil,地址值就是0

### 结构体

回来了,都回来了,大一学的C语言和c++,后面被迫转java,java是很好,但是我觉得还是有点笨重,当然他的出现也是为了解决问题

```go
type people struct{
	age int
	name string
}
```

这个传入参数也是值类型哦,不是引用类型,和c++是一样的,主要跟java的区别

### Range关键字

用于 for 循环中迭代数组,切片,通道,集合中的元素,并以k-v的方式返回

### 数据结构

让我们来感受一下go提供的数据结构吧

#### 切片

哎呦我去,这不就是java的list,c++的vector,python里面的切片么

```go
s = []int{1,2,3} //注意跟数组定义的区别哦,中括号里面是没有东西的哦
s := make([]int,3) //或者这样哦
```

切片是可以动态增长的哦,不像数组.既然叫切片,那让我们来看看它怎么切吧

```go
// len 是数组的长度
s := arr[:] //切片是整个数组[0,len)
s := arr[start:] //从start到整个数组后面 [start,len)
s := arr[:end] //从0到end-1 [0,end)
```

##### 切片常用函数

len() 计算当前数据长度,cap() 计算最大可达长度

append(slice,val) 向切片追加数据 ,copy(destnation,src) 复制一个切片到另一个切片

make(slicetype,len,cap)  定义一个切片当前大小为len,总容量为cap的切片

### map


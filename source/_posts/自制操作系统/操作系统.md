---
title: 自制操作系统
date: 2023-10-17
---

# 启动

## BIOS

basic input output system  基本输入输出系统

BIOS启动流程:  加电自检,  然后读出启动盘的第一个扇区 到 0x7c00 位置  然后调整到 0x7c00位置执行代码,   这个时候把执行权限交给我们,  我们需要将代码写入到第一个扇区, 然后将操作系统加载到内存中

此时CPU处于的模式是在实模式下 ,  在这个模式下我们能够直接操作内存, 想怎么操作怎么操作,  但是只有1M的寻址空间

# 中断

## 实模式

实模式下,  系统通过中断号, 在中断向量表中找到对应的中断向量, 中断向量 是由cs:ip 组成, 记录了中断处理函数的位置

## 保护模式

保护模式下, 系统通过中断号, 在中断描述符表中找到中断描述符,   中断描述符中记录了很多信息

```c++
typedef struct gate_t
{
    u16 offset0;    // 段内偏移 0 ~ 15 位
    u16 selector;   // 代码段选择子
    u8 reserved;    // 保留不用
    u8 type : 4;    // 任务门/中断门/陷阱门
    u8 segment : 1; // segment = 0 表示系统段
    u8 DPL : 2;     // 使用 int 指令访问的最低权限
    u8 present : 1; // 是否有效
    u16 offset1;    // 段内偏移 16 ~ 31 位
} _packed gate_t;
```

通过中断描述符就能找到中断处理函数了

### 加载中断描述符表

定义中断描述符表

```
#define ENTRY_SIZE 0x30   // 这里可以根据需要更改, 这里只定义一些常用的
gate_t idt[IDT_SIZE];
```

中断描述符指针

```
typedef struct pointer_t
{
    u16 limit; 
    u32 base;
} _packed pointer_t;
pointer_t idt_ptr;  // 中断描述符指针
idt_ptr.base = (u32)idt;
idt_ptr.limit = sizeof(idt)-1;
```

加载中断描述符表

```
asm volatile("lidt idt_ptr\n"); 
```

### 中断函数编写思路

首先定义一个做验证, 和 保存上下文 和 恢复上下文的函数 handle_entry 作为中断描述符入口地址,   里面调用 handle 函数 来处理真正的中断,


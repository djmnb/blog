

# 第一章 对象入门

拟出一个计划

首先我们应该要明白我们的程序需要做什么,而不是考虑程序要怎么做,我们应该将重心放到这一阶段的核心问题上,不要纠结与一些细枝末节,同时也不要过分在意系统的**"完美"**,否则容易产生挫败感和焦虑情绪

对自己的系统做一些**"名词"**和**"动词"**的描述,名词成为自然对象,动词成为对象接口中的方法

根据自己的经验与直觉,对一个项目进行日程估计,然后在这个时间上再加上百分之十,如果按时完成了,那么这个百分之十的时间,可以用来完善项目



如何构建计划呢? 通常建议使用UML很好





```
{
    int x;
    {
        int x; //在java里面,这个是非法的
    }
}
```



**java的包名命名规范一般是域名倒着来,首先,我们是想包名唯一,正好域名是唯一的,但是域名后两个是固定的,前面又可以随便变化,所以域名符合要求**,而且我们为了方便管理,还要把域名倒过来才行,假如我有个域名 djm.com  那么 ww.djm.com,abc.djm.com  不都是我的子域名么,如果正着来,不好管理啊,反着来,前面都一样,好管理

@Override 是重写  发生在子父类之间(同名,同参数,而且子类访问权限不能小于父亲,子类异常也要是父类的异常的子类)

@Overload 是重载  发生在本类中(同名,不同参数)

# 第二章 一切都是对象

堆里面存放对象句柄,也就是对象的内存地址, 而堆里面存放对象

## 堆和栈

在 Java 中，堆（Heap）和栈（Stack）是两种不同的内存区域，它们在内存分配和数据存储方面有着本质的区别。下面是它们之间的一些主要差异：

1. 存储内容：
   堆：主要存储对象实例和数组。
   栈：主要存储基本类型变量（如 int、float、boolean 等）及对象引用变量。

2. 内存分配：
   堆：**在运行时动态分配内存**，根据需要申请和释放内存空间。内存分配速度相对较慢。
   栈：**在编译时静态分配内存**，随着方法的调用和返回而自动分配和释放内存空间。内存分配速度较快。

3. 生命周期：
   堆：堆中的对象实例的生命周期取决于垃圾回收器。当对象不再被引用时，垃圾回收器会自动回收其占用的内存。
   栈：栈中的数据的生命周期与方法调用和返回的生命周期相对应。当方法返回时，其栈帧（包含局部变量和引用变量）会自动销毁。

4. 访问速度：
   堆：相对较慢，因为堆是在运行时动态分配内存。
   栈：相对较快，因为栈是在编译时静态分配内存。

5. 内存管理：
   堆：由垃圾回收器负责管理内存，对于不再使用的对象实例进行回收。
   栈：内存管理相对简单，随着方法的调用和返回自动分配和释放内存空间。

6. 容量大小：
   堆：堆的容量通常比栈大得多，因为它需要存储所有创建的对象实例和数组。
   栈：栈的容量相对较小，通常只存储局部变量和引用变量。

总之，堆和栈在 Java 中扮演着不同的角色，它们各自负责存储不同类型的数据和管理内存。了解它们的区别有助于编写更高效、更可靠的 Java 程序。

> 堆就是堆,而不是树,我总是将堆跟树联系起来

## 基本数据类型

Java 中有 8 种基本数据类型，它们的大小如下：

1. byte（字节）：占用 8 位（1 字节），取值范围为 -128 到 127。
2. short（短整型）：占用 16 位（2 字节），取值范围为 -32,768 到 32,767。
3. int（整型）：占用 32 位（4 字节），取值范围为 -2,147,483,648 到 2,147,483,647。
4. long（长整型）：占用 64 位（8 字节），取值范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。
5. float（单精度浮点型）：占用 32 位（4 字节），取值范围约为 -3.4e38 到 3.4e38，精度约为 7 位小数。
6. double（双精度浮点型）：占用 64 位（8 字节），取值范围约为 -1.8e308 到 1.8e308，精度约为 16 位小数。
7. char（字符型）：占用 16 位（2 字节），取值范围为 0 到 65,535，用于表示 Unicode 字符。
8. boolean（布尔型）：占用的位数在不同的 Java 虚拟机实现中可能不同，通常为 8 位（1 字节）或 32 位（4 字节），只有两个取值：true 和 false。

这些基本数据类型直接存储在栈内存中，它们不是对象，因此不需要通过引用访问。在 Java 中，基本数据类型的大小是固定的，不会因为操作系统或硬件平台的不同而发生变化。

## 内存泄漏的情况

在 Java 中，内存泄漏是指一些不再需要的对象占用的内存无法被**垃圾回收器回收，导致内存资源无法释放**。以下是一些可能导致内存泄漏的常见情况：

1. 长生命周期对象持有短生命周期对象的引用：如果一个长生命周期的对象（例如静态变量、单例对象）持有一个短生命周期对象的引用，即使短生命周期对象不再使用，垃圾回收器也无法回收它，因为仍然存在对它的引用。

2. 集合类对象：集合类（如 ArrayList、HashMap 等）可能会导致内存泄漏，特别是在长生命周期对象中。如果不及时清理集合中不再使用的对象，它们会一直占用内存。

3. 监听器和回调：当一个对象注册为另一个对象的监听器或回调时，它可能会导致内存泄漏。如果在不再需要监听或回调时没有取消注册，这些对象将继续存在并占用内存。

4. 内部类和外部类之间的引用：非静态内部类会隐式持有一个对其外部类的引用。如果外部类的生命周期比内部类长，且内部类对象长时间存在，可能会导致内存泄漏。可以考虑将内部类更改为静态内部类以避免此问题。

5. 资源未关闭：在 Java 应用中，使用到的一些资源（如文件流、数据库连接等）需要在使用完毕后显式关闭。如果没有正确关闭这些资源，它们可能会导致内存泄漏。

6. 线程泄漏：线程本身也会占用内存资源，特别是线程的栈内存。如果线程没有正确终止，可能导致内存泄漏。线程池的不当使用也可能导致线程泄漏，因此要确保合理配置线程池，并在任务完成后正确释放线程。

要避免内存泄漏，需要密切关注程序中的对象引用、资源管理和线程管理等方面。在开发过程中，可以使用一些内存分析工具（如 VisualVM、MAT 等）来检测和分析内存泄漏。



java只会为**类的属性自动初始化(基本数据类型有其默认值,对象为空),而不会为局部变量进行初始化**,因此局部变量如果没有初始化,便会报错,这里是跟c++的区别,这种思想也合理吧,局部变量你不初始化说明你压根用不着,又何必定义,但是也不太合理,如果我是在一个条件里面初始化,那么外界又拿不到,外界初始化的话就得给一个值先冒充着

## 总结

本章的话大致讲了一些基础东西,比如栈,堆,类的基本定义啊,文档注释这些

# 第三章 控制程序流程

> 就象任何有感知的生物一样，程序必须能操纵自己的世界，在执行过程中作出判断与选择。

## 运算符

Java 中有许多运算符，可以根据功能和优先级分为以下类别：

1. 后缀运算符：
   - `expr++`：后缀递增
   - `expr--`：后缀递减

2. 一元运算符：
   - `++expr`：前缀递增
   - `--expr`：前缀递减
   - `+expr`：正号
   - `-expr`：负号
   - `!expr`：逻辑非（布尔取反）
   - `~expr`：按位非（按位取反）

3. 类型转换运算符：
   - `(type) expr`：类型转换（强制类型转换）

4. 算术运算符：
   - `*`：乘法
   - `/`：除法
   - `%`：取模（求余数）
   - `+`：加法
   - `-`：减法

5. 移位运算符：
   - `<<`：左移
   - `>>`：右移（带符号）
   - `>>>`：无符号右移

6. 关系运算符：
   - `<`：小于
   - `<=`：小于等于
   - `>`：大于
   - `>=`：大于等于
   - `instanceof`：类型检查

7. 相等运算符：
   - `==`：相等
   - `!=`：不等

8. 位运算符：
   - `&`：按位与
   - `^`：按位异或
   - `|`：按位或

9. 短路逻辑运算符：
   - `&&`：逻辑与（短路）
   - `||`：逻辑或（短路）

10. 条件运算符（三元运算符）：
    - `expr1 ? expr2 : expr3`：条件表达式

11. 赋值运算符：
    - `=`：赋值
    - `+=`：加法赋值
    - `-=`：减法赋值
    - `*=`：乘法赋值
    - `/=`：除法赋值
    - `%=`：取模赋值
    - `<<=`：左移赋值
    - `>>=`：右移赋值
    - `>>>=`：无符号右移赋值
    - `&=`：按位与赋值
    - `^=`：按位异或赋值
    - `|=`：按位或赋值

运算符优先级（从高到低）：

1. 后缀运算符
2. 一元运算符
3. 类型转换运算符
4. 算术运算符（`*`、`/`、`%` 优先于 `+`、`-`）
5. 移位运算符
6. 关系运算符
7. 相等运算符
8. 位运算符（`&` 优先于 `^`,^` 优先于 `|)
9. `短路逻辑运算符（`&&` 优先于 `||`）
10. 条件运算符（三元运算符）
11. 赋值运算符

请注意，在表达式中使用多个运算符时，优先级相同的运算符将根据其结合性从左到右（或从右到左）进行求值。大多数运算符（如算术、关系、位运算等）具有从左到右的结合性，而一元运算符、赋值运算符和条件运算符则具有从右到左的结合性。

为了提高代码的可读性和可维护性，建议使用括号明确地指定运算符的优先级，而不是仅依赖于运算符的默认优先级。这可以帮助避免因误解优先级而导致的错误。



## java 为什么没有sizeof ?

因为他不需要,c++和c有sizeof 是因为在不同的平台里面,有些数据类型的大小是不一样的,new 数据的时候就得通过sizeof去控制

## 流程控制

Java 中的流程控制结构可以分为三大类：顺序结构、分支结构和循环结构

### 顺序结构

顺序结构中的代码会按照它们在源文件中的顺序自上而下执行。

```java
statement1;
statement2;
statement3;
...
```

### 分支结构

#### if 语句

```java
if (condition) {
    // 当条件为真时执行的代码块
}
```

- if-else 语句

```java
if (condition) {
    // 当条件为真时执行的代码块
} else {
    // 当条件为假时执行的代码块
}
```

- if-else if-else 语句

```java
if (condition1) {
    // 当条件1为真时执行的代码块
} else if (condition2) {
    // 当条件1为假，且条件2为真时执行的代码块
} else {
    // 当所有条件均为假时执行的代码块
}
```

#### switch 语句

```java
switch (expression) {
    case value1:
        // 当 expression 等于 value1 时执行的代码块
        break;
    case value2:
        // 当 expression 等于 value2 时执行的代码块
        break;
    ...
    default:
        // 当 expression 与所有 case 值都不匹配时执行的代码块
}
```

- `expression`：用于与 `case` 语句中的值进行比较的表达式。在 Java 7 之前，该表达式只能是整型（byte、short、char、int）或枚举类型；从 Java 7 开始，还可以是字符串类型。
- `case`：定义了一个与 `expression` 进行比较的值,这个值必须与expression的返回值类型相同。如果 `expression` 等于 `case` 后的值，那么将执行该 `case` 语句下的代码块。
- `break`：用于跳出 `switch` 语句。如果不使用 `break`，则代码将继续执行下一个 `case` 语句，直到遇到 `break` 或 `switch` 结构结束。
- `default`：当 `expression` 与所有 `case` 值都不匹配时执行的代码块。`default` 语句是可选的，可以省略。

注意点

1. 唯一的 case 值：确保每个 `case` 语句的值都是唯一的，以避免产生歧义。具有相同值的多个 `case` 语句会导致编译错误。

### 循环结构

- for 循环

```java
for (initialization; condition; update) {
    // 当条件为真时执行的代码块，每次迭代后执行更新操作
}
```

- while 循环

```java
while (condition) {
    // 当条件为真时执行的代码块
}
```

- do-while 循环

```java
do {
    // 代码块至少执行一次，然后在条件为真时继续执行
} while (condition);
```

请注意，这些格式只是通用模板。在实际编程中，您可能需要根据具体需求对这些结构进行适当的修改。同时，为了提高代码的可读性，建议在复杂的逻辑中使用括号和适当的缩进。

> 对于condition,必须是bool表达式



## 总结

本小结主要讲述了java中的运算符,计算,类型转换,还有流程控制,中规中矩

# 第四章 初始化与清除



## 初始化

### 类的初始化

类的初始化是指在类首次加载到 JVM（Java 虚拟机）时执行的过程。类的初始化主要包括静态变量的赋值和静态代码块的执行。这些操作仅在类加载时执行一次。类初始化如下：

- 静态变量赋值：按照它们在类中出现的顺序为静态变量分配内存并赋初值。
- 静态代码块执行：按照它们在类中出现的顺序执行静态代码块。

> 会按照static关键字的定义顺序来依次执行,静态变量和静态代码块的初始化顺序取决于它们在类中的出现顺序。为了避免在静态代码块中访问尚未初始化的静态变量，确保在静态代码块之前对静态变量进行初始化。

### 对象初始化

 对象的初始化是指创建对象实例并为实例变量分配内存和初始值的过程。对象初始化如下：

- 分配内存：为对象分配内存空间。
- 实例变量赋值：按照它们在类中出现的顺序为实例变量分配内存并赋初值。
- 实例初始化块执行：按照它们在类中出现的顺序执行实例初始化块。
- 构造函数执行：调用相应的构造函数以进一步初始化对象。

> 同理,实例变量和实例代码块的初始化顺序取决于它们在类中的出现顺序

综上所述，类的初始化和对象的初始化是 Java 中创建和使用对象的两个关键步骤。类的初始化负责静态变量的赋值和静态代码块的执行，而对象的初始化则涉及实例变量的赋值、实例初始化块的执行和构造函数的调用。类的初始化只在类加载时执行一次，而对象的初始化在每次创建新对象时执行。

## 资源问题

如果程序结束了,那么它占用的资源都会归还给操作系统,比如你打开一个文件流,忘记关闭了,程序结束后,还是会归回给操作系统,不过这样并不是一个好习惯,如果我们的程序是要一直执行的,那么这样会浪费系统资源., 但是即使是一次执行的程序,不关闭文件也会存在一些潜在问题:

1. 文件锁定：在程序运行期间，如果文件没有被正确关闭，其他程序可能无法访问或修改该文件。这可能导致数据不一致或协同工作问题。

2. 程序行为不稳定：当打开的文件数量达到系统允许的最大值时，操作系统可能会拒绝打开新文件。这可能导致程序行为不稳定，甚至崩溃。

3. 不良编程习惯：不养成正确关闭资源的习惯可能导致在其他项目或长时间运行的程序中出现问题。遵循最佳实践，始终确保在使用完资源后正确关闭它们。

因此，尽管在一次性执行的程序中，未关闭的文件流可能不会导致长期问题，但仍然建议采用诸如 try-with-resources 语句等方法来确保文件流在使用完毕后被正确关闭。这有助于避免潜在问题，提高代码质量和可维护性。

## 总结

这章主要讲了一些类的初始化,垃圾回收器,方法重载的东西

# 第五章 隐藏实施过程

* **进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开**

* **创建自己的包时，要求 package 语句必须是文件中的第一个“非注释”代码**

* **编译器遇到 import 语句后，它会搜索由CLASSPATH 指定的目录,然后查找名称适当的已编译文件(.class文件)**
* **为导入的类首次创建一个对象时（或者访问一个类的static 成员时）**，编译器会在适当的目录里寻找同名的.class 文件（所以如果创建类 X 的一个对象，就应该是 X.class）。若只发现X.class，它就是必须使用的那一个类。然而，如果它在相同的目录中还发现了一个 X.java，编译器就会比较两个文件的日期标记。如果X.java 比X.class 新，**就会自动编译 X.java，生成一个最新的 X.class。**

## 访问修饰符

Java 中有四种访问修饰符，用于限制类、方法、变量和内部类的可见性和访问范围。它们是：public, private, protected 和默认（即不使用任何修饰符，有时也称为“包私有”或“默认访问”）。

1. public：
   - 描述：被 public 修饰的**类、方法或变量**可以在任何地方被访问。
   - 类：public 类可以被任何其他类访问。
   - 方法和变量：public 方法和变量可以被该类的所有对象和任何其他类访问。
   - 内部类：public 内部类可以在任何地方被访问。

2. private：
   - 描述：被 private 修饰的**方法或变量**只能在声明它们的类中被访问。
   - 类：**private 不能修饰顶级类，但可以修饰内部类**。
   - 方法和变量：private 方法和变量只能在声明它们的类中被访问，不能在该类的子类或其他类中访问。
   - 内部类：private 内部类只能在声明它的类中被访问。

3. protected：
   - 描述：被 protected 修饰的方法或变量可以在声明它们的类中、该类的子类以及同一包中的其他类中被访问。
   - 类：**protected 不能修饰顶级类，但可以修饰内部类。**
   - 方法和变量：protected 方法和变量可以在声明它们的类中、该类的子类以及同一包中的其他类中被访问。
   - 内部类：protected 内部类可以在声明它的类中、该类的子类以及同一包中的其他类中被访问。

4. 默认（包私有）：
   - 描述：不使用任何访问修饰符的**类、方法或变量**只能在同一包中被访问。
   - 类：默认访问的类只能在同一包中的其他类访问。
   - 方法和变量：默认访问的方法和变量可以在声明它们的类中以及同一包中的其他类中被访问。
   - 内部类：**默认访问的内部类可以在声明它的类中以及同一包中的其他类中被访问**。

总结：
- public：最开放的访问级别，可以在任何地方被访问。
- private：最严格的访问级别，只能在声明它的类中访问。
- protected：可以在声明它的类中、该类的子类以及同一包中的其他类中访问。
- 默认（包私有）：只能在同一包中的类访问。

> private > 默认 > protected > public

选择适当的访问修饰符有助于保护数据和保护数据和实现封装。通过限制对类、方法和变量的访问，可以确保它们的正确使用，并防止意外修改或错误的操作。

在实际编程中，通常遵循以下原则：

1. 最小权限原则：总是尽量使用最严格的访问修饰符。这有助于保护数据和实现封装，确保类的内部实现不会被外部错误地访问或修改。例如，如果一个变量只在类内部使用，那么将其声明为 private。

2. 面向接口编程：对外暴露接口，隐藏实现细节。通过使用 public 访问修饰符为类提供公共接口，**同时将内部实现细节封装在 private 和 protected 成员中**。

3. 适当使用包和模块：通过将相关的类组织在同一个包或模块中，可以使用默认（包私有）访问修饰符来限制它们的可见性范围。这可以使代码结构更加清晰，并减少错误的可能性。

4. 保护继承：对于需要子类访问的成员，可以使用 protected 访问修饰符。这允许子类访问和重写这些成员，同时仍然限制其他类的访问。

总之，合理地使用访问修饰符有助于保护数据和实现封装，确保类的正确使用和扩展。要充分理解每种访问修饰符的特点，并在实际编程中灵活运用。

> 

## 总结

本章主要讲了包和访问修饰符(public protected default private)



# 第六章 类的派生



## 继承

好的，让我们详细了解一下Java中的类继承。

1. 继承的概念
   继承是面向对象编程中的一个核心概念，它允许一个类从另一个类继承属性和方法。继承的主要目的是实现代码的复用和扩展。在Java中，继承使用关键字 `extends` 表示。

2. 基类（父类）与子类
   - 父类（也称为基类或超类）：被其他类继承的类。父类包含的属性和方法可以被子类继承。
   - 子类：从父类继承属性和方法的类。子类可以扩展和修改从父类继承的属性和方法。

3. 继承的语法
   子类使用关键字 `extends` 继承父类。例如：
   ```java
   class Parent {
       // 父类的属性和方法
   }
   
   class Child extends Parent {
       // 子类的属性和方法
   }
   ```

4. 访问控制与继承
   - **private成员（属性和方法）不能被子类直接访问。**
   - **默认访问权限（没有访问修饰符）的成员可以被同一个包中的子类访问。**
   - protected成员可以被同一个包中的子类以及不同包中的子类访问。
   - public成员可以被任何地方的子类访问。

5. 方法重写（覆盖）
   子类可以重写从父类继承的方法，以提供新的实现。重写方法的要求：
   - 方法名、参数列表和返回类型必须与父类方法相同。
   - 访问修饰符不能比父类方法更严格。
   - 重写方法不能抛出比父类方法更多的受检异常。

6. super关键字
   子类可以使用super关键字引用父类的成员（属性和方法）。
   - super调用父类的构造方法：`super()` 必须是子类构造方法中的第一个语句。
   - super访问父类的属性：`super.attribute`
   - super调用父类的方法：`super.method()`

7. final关键字与继承
   - 如果一个类用final修饰，那么它不能被继承。例如：`final class A {}`
   - 如果一个方法用final修饰，那么它不能被子类重写。例如：`final void method() {}`
   - 如果一个变量被final修饰,那么它不能被修改这里的修改指的是修改它对应的地址值

8. 抽象类与抽象方法
   - 抽象类：使用关键字 `abstract` 定义的类，不能被实例化。抽象类可以包含抽象方法和具体方法。
   - 抽象方法：使用关键字 `abstract` 定义的方法，没有方法体。抽象方法必须在抽象类中定义，子类需要提供实现。

   ```java
   abstract class Animal {
       abstract void sound(); // 抽象方法，没有方法体
       
       void move() {
           // 具体方法
           System.out.println("Animal is moving");
       }
   }
   
   class Dog extends Animal {
       // 子类必须实现抽象方法
       void sound() {
           System.out.println("Dog barks");
       }
   }
   
   ```

   

9. 接口与继承 接口是Java中的一种特殊类型，它包含了一组**抽象方法（Java 8引入了默认方法和静态方法）**。实现接口的类必须提供接口中所有方法的实现。一个类可以实现多个接口，使用关键字 `implements`。

   语法示例：

   ```java
   csharpCopy codeinterface Flyable {
       void fly();
   }
   
   interface Swimmable {
       void swim();
   }
   
   class Bird implements Flyable, Swimmable {
       // 实现接口中的方法
       void fly() {
           System.out.println("Bird flies");
       }
   
       void swim() {
           System.out.println("Bird swims");
       }
   }
   ```

10. 多重继承与接口 **Java不支持多重继承**（一个类继承多个类），但可以通过实现多个接口来实现多重继承的效果。一个类可以同时实现多个接口，从而继承接口中的方法。

11. 构造器与继承 子类构造方法默认调用父类的无参构造方法。如果父类没有提供无参构造方法，那么子类必须使用super关键字显式调用父类的构造方法。**(必须是方法体的第一条语句)**

    语法示例：

    ```java
    javaCopy codeclass Parent {
        Parent(int a) {
            // 父类的构造方法
        }
    }
    
    class Child extends Parent {
        Child(int a) {
            super(a); // 显式调用父类的构造方法
        }
    }
    ```

### 属性冲突

在 Java 继承和接口实现中，属性冲突主要包括以下两种情况：

1. 类继承中的属性冲突：

   当子类和父类中具有相同名称的属性时，子类中的属性会遮蔽父类中具有相同名称的属性。也就是说，当在子类中访问该属性时，将访问子类中的属性，而不是父类中的属性。但是可以通过 `super` 关键字显式地访问父类中的属性。例如：

   ```
   class Parent {
       String name = "Parent";
   }

   class Child extends Parent {
       String name = "Child";

       void printNames() {
           System.out.println(name);         // 输出 "Child"
           System.out.println(super.name);    // 输出 "Parent"
       }
   }
   ```

2. 接口实现中的属性冲突：

   接口可以定义属性（默认为 `public static final`），当一个类实现多个接口，且这些接口具有相同名称的属性时，可能会出现冲突。在这种情况下，实现类需要显式指定访问哪个接口的属性，否则会出现编译错误。例如：

   ```java
   interface InterfaceA {
       String name = "InterfaceA";
   }
   
   interface InterfaceB {
       String name = "InterfaceB";
   }
   
   class Implementor implements InterfaceA, InterfaceB {
       void printNames() {
           System.out.println(InterfaceA.name); // 输出 "InterfaceA"
           System.out.println(InterfaceB.name); // 输出 "InterfaceB"
           //System.out.println(name);         // 编译错误，因为不明确是访问 InterfaceA 还是 InterfaceB 的属性
       }
   }
   ```

综上所述，要避免属性冲突，最佳实践是：

- 尽量避免在子类和父类、接口之间使用相同名称的属性。
- 如果确实需要访问父类或接口中的同名属性，可以使用 `super` 关键字（对于父类属性）或显式指定接口名称（对于接口属性）进行访问。

> 如果父类和接口属性冲突了的话,那么父类属性变量优先,如果遇到了冲突想要使用父类或者接口中的值的话,得指定类名或者接口名字,而且必须在类中才能这样,比如在某个方法里面使用 super.变量 或者 接口名字.变量

## 总结

本章主要讲了继承的相关知识点,以及final的用法

# 第七章 多态性

## 内部类

### 定义

Java 中的内部类是指在一个类的内部定义的类。内部类主要用于**组织和封装代码**，使代码结构更加清晰。根据其声明位置和特点，内部类可以分为以下四种类型：

1. 成员内部类（Member Inner Class）：
   - 成员内部类是在一个类的内部声明的**非静态类**。
   - **成员内部类可以访问外部类的所有成员（包括私有成员）**。
   - **要创建成员内部类的实例，需要先创建外部类的实例**。
   - **成员内部类不能包含静态成员（除非是编译时常量）。**
   - 成员内部类可以使用外部类的访问修饰符（public, private, protected, 默认）。

2. 静态内部类（Static Inner Class）：
   - 静态内部类是在一个类的内部声明的静态类。
   - **静态内部类可以访问外部类的静态成员（包括私有静态成员），但不能访问外部类的非静态成员。**
   - 创建静态内部类的实例**不需要先创建外部类的实例。**
   - 静态内部类可以包含静态成员和非静态成员。
   - 静态内部类可以使用外部类的访问修饰符（public, private, protected, 默认）。

3. 局部内部类（Local Inner Class）：
   - **局部内部类是在一个方法或代码块内部声明的类。**
   - 局部内部类只能访问所在方法中被声明为 final 或者是 effectively final 的局部变量（从 Java 8 开始）。
   - 局部内部类不能使用访问修饰符，其可见性仅限于声明它的方法或代码块。
   - 局部内部类不能包含静态成员（除非是编译时常量）。
   - 创建局部内部类的实例需要在其所在方法或代码块内部进行。

4. 匿名内部类（Anonymous Inner Class）：
   - 匿名内部类是一种没有类名的内部类，通常用于创建临时的类实例。
   - 匿名内部类可以继承一个类或实现一个接口，但不能同时继承多个类或接口。
   - **匿名内部类只能访问所在方法中被声明为 final 或者是 effectively final 的局部变量（从 Java 8 开始）**。
   - 匿名内部类不能包含静态成员（除非是编译时常量）。
   - 创建匿名内部类的实例需要在其所在方法或代码块内部进行，通常通过 new 操作符实现。

总结：内部类是 Java **提供的一种强大的代码组织和封装机制**。了解不同类型的内部类及其特点，可以帮助您在实际编程中更加灵活地运用内部类来实现代码的封装和模块化。以下是一些内部类的典型用途和注意事项：

1. 封装：内部类可以访问外部类的成员，这使得它们成为实现封装的理想选择。通过将与外部类密切相关的功能实现在内部类中，可以使外部类更加简洁，更易于理解和维护。

2. 实现回调和事件处理：匿名内部类通常用于实现回调和事件处理，因为它们可以直接访问所在方法的局部变量和外部类的成员。这在实现图形用户界面（GUI）等事件驱动程序时特别有用。

3. 实现多重继承：虽然 Java 不支持多重继承，但可以通过使用内部类来实现类似的功能。外部类可以包含多个内部类，每个内部类分别继承或实现不同的类或接口。

4. 静态内部类和单例模式：静态内部类可以用于实现单例模式，因为它们不依赖于外部类的实例。这可以确保类在整个应用程序中只有一个实例，从而节省资源并提高性能。

注意事项：

1. 避免内部类和外部类之间的过度耦合。虽然内部类可以访问外部类的成员，但过度使用这种关系可能导致代码难以理解和维护。尽量让内部类和外部类之间的关系清晰，遵循单一职责原则。

2. 谨慎使用匿名内部类。匿名内部类在某些场景下非常有用，但它们的可读性较差。在需要实现复杂逻辑的情况下，考虑使用具名的内部类或外部类。

3. 考虑性能影响。成员内部类、局部内部类和匿名内部类都需要隐式地持有对外部类实例的引用。这可能导致内存泄漏和性能问题。在这种情况下，可以考虑使用静态内部类，因为它们不持有对外部类实例的引用。

通过了解和掌握内部类的特点和用法，您可以更有效地利用 Java 语言的特性，编写出更加清晰、易于维护的代码。

### 使用例子

以下是几种内部类的示例，包括正确和错误的用法。

1. 成员内部类：

正确用法：

```java
class Outer {
    private String message = "Hello, Inner!";

    class Inner {
        void printMessage() {
            System.out.println(message); // 访问外部类的成员变量
        }
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner(); // 创建内部类实例
        inner.printMessage();
    }
}
```

错误用法：

```java
class Outer {
    private String message = "Hello, Inner!";

    class Inner {
        static String staticMessage = "Static message"; // 成员内部类不能有静态变量
    }
}
```

2. 静态内部类：

正确用法：

```java
class Outer {
    static String message = "Hello, Static Inner!";

    static class StaticInner {
        void printMessage() {
            System.out.println(message); // 访问外部类的静态成员变量
        }
    }

    public static void main(String[] args) {
        Outer.StaticInner inner = new Outer.StaticInner(); // 创建静态内部类实例
        inner.printMessage();
    }
}
```

错误用法：

```java
class Outer {
    private String message = "Hello, Static Inner!";

    static class StaticInner {
        void printMessage() {
            System.out.println(message); // 静态内部类不能访问外部类的非静态成员变量
        }
    }
}
```

3. 局部内部类：

正确用法：

```java
class Outer {
    void createLocalInner() {
        final String message = "Hello, Local Inner!";

        class LocalInner {
            void printMessage() {
                System.out.println(message); // 访问所在方法的局部变量（必须是 final 或 effectively final）
            }
        }

        LocalInner localInner = new LocalInner();
        localInner.printMessage();
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.createLocalInner();
    }
}
```

错误用法：

```java
class Outer {
    void createLocalInner() {
        String message = "Hello, Local Inner!";

        class LocalInner {
            void changeMessage() {
                message = "New message"; // 局部内部类不能修改所在方法的局部变量
            }
        }
    }
}
```

4. 匿名内部类：

正确用法：

```java
interface Printer {
    void printMessage(String message);
}

class Outer {
    void createAnonymousInner() {
        Printer printer = new Printer() {
            @Override
            public void printMessage(String message) {
                System.out.println(message);
            }
        };

        printer.printMessage("Hello, Anonymous Inner!");
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.createAnonymousInner();
    }
}
```

错误用法：

```java
interface Printer {
    void printMessage(String message);
}

class Outer {
    void createAnonymousInner() {
        String message = "Hello, Anonymous Inner!";
        Printer printer = new Printer() {
            @Override
            public void printMessage(String newMessage) {
                message = newMessage; // 匿名内部类不能修改所在方法的局部变量（除非变量是 final 或 effectively final
            }
        }
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.createAnonymousInner();
    }
}

```

> 上述列子是在jdk8中使用的,其实在jdk15以后,就有些区别了,比如成员内部类允许有静态变量,局部内部类和匿名内部类可以访问非final变量

### 内部类的用处

内部类在 Java 编程中有很多用途，主要包括以下几点：

1. **封装**：内部类可以帮助将类的实现细节隐藏起来，使得外部类更简洁。它使得与外部类关系紧密的类能够被组织在一起，而不需要暴露给外部其他类。
2. **增强可读性和维护性**：将与某个类紧密相关的辅助类或逻辑组织在一起，可以提高代码的可读性和维护性。这样，相关代码可以在一个地方进行修改和维护，而不是分散在多个地方。
3. **访问外部类成员**：非静态内部类可以访问外部类的所有成员（包括私有成员），而无需显式传递引用。这使得编写能够访问外部类成员的方法更简单和高效。
4. **实现多重继承**：Java 不支持多重继承，但可以通过内部类实现一种形式的多重继承。你可以创建一个内部类，使其继承自另一个类，这样外部类就可以间接地继承内部类的父类。
5. **用于回调和事件处理**：内部类常用于回调和事件处理。例如，在图形用户界面（GUI）编程中，匿名内部类通常用于实现事件监听器。这样可以将事件处理逻辑与其他代码分离，提高代码的组织和可读性。

## 总结

内部类(静态内部类 成员内部类 局部内部类 匿名内部类), 内部类这里在不同版本有不同的表现,在jdk16开始就有了一些变化

# 补充

## 类的加载

类的加载是 Java 运行时环境在执行 Java 程序时将类加载到 Java 虚拟机（JVM）中的过程。类的加载包括以下几个阶段：

1. 加载（Loading）：JVM 从文件系统、网络或其他资源中加载类的二进制数据（字节码文件），并根据这些数据在 JVM 内存中创建一个 java.lang.Class 对象。这个阶段主要由类加载器（Class Loader）完成。仅导入类（使用 import 语句）不会触发类加载，类加载发生在实际使用类时，如创建对象、访问静态变量或方法等。

2. 验证（Verification）：在加载阶段之后，JVM 对字节码文件进行验证，确保它符合 Java 语言规范，不包含非法指令，保证其正确性和安全性。

3. 准备（Preparation）：在验证阶段之后，JVM 为类的静态变量分配内存并设置默认值。例如，对于基本类型的静态变量，整数型变量会被设置为 0，浮点型变量会被设置为 0.0，布尔型变量会被设置为 false，引用类型变量会被设置为 null。

4. 解析（Resolution）：在准备阶段之后，JVM 对类中的符号引用进行解析，将其替换为直接引用。符号引用是指用类、字段或方法的名字和描述符来表示，而直接引用是指用内存地址或偏移量来表示。解析阶段保证了类、字段和方法的使用可以被正确地定位。

5. 初始化（Initialization）：在解析阶段之后，JVM 对类进行初始化，执行类的静态代码块和静态变量赋值操作。这些操作按照它们在类中出现的顺序执行。

在 Java 中，**类的加载通常是惰性的（按需加载）。这意味着类在实际使用之前不会被加载。仅导入类（使用 import 语句）不会触发类的加载**。类加载发生在以下情况：

- 创建类的实例（使用 new 关键字）。
- **访问类的静态变量**。
- **调用类的静态方法**。
- **使用反射来创建实例、访问变量或调用方法。**
- **初始化子类时，父类会先被加载**。

当类被加载到 JVM 时，只有在实际使用类的过程中，类的加载才被认为已经完成。

## jar包

要将 Java 程序打包成 JAR 文件，您可以使用 JDK 提供的 `jar` 命令。以下是一个简单的步骤：

1. 确保您已经编译了 Java 源代码，生成了 `.class` 文件。

2. 创建一个名为 `manifest.txt` 的清单文件，其中包含一个 `Main-Class` 项，指定应用程序的入口类。例如，如果您的程序入口类为 `com.example.Main`，则 `manifest.txt` 文件的内容应为：
   ```
   Main-Class: com.example.Main
   ```

   > 文件内容可以没有,但是文件一定要有

3. 使用 `jar` 命令创建 JAR 文件。将 `-c`（创建新的 JAR 文件）、`-v`（详细输出）和 `-f`（指定 JAR 文件名）选项与清单文件和要打包的 `.class` 文件一起传递。 **可以传递多个文件,不限于.class文件**

   ```
   jar -cvfm myprogram.jar manifest.txt com/example/*.class test.txt
   ```
   这个命令将创建一个名为 `myprogram.jar` 的 JAR 文件，包含 `manifest.txt` 清单文件和 `com/example` 目录下的所有 `.class` 文件。

4. 确认 JAR 文件已成功创建。可以使用 `jar` 命令的 `-t`（列出 JAR 文件内容）选项查看 JAR 文件中的文件：
   ```
   jar -tvf myprogram.jar
   ```

5. 使用 `java` 命令运行 JAR 文件：
   ```
   java -jar myprogram.jar
   ```
   这个命令将启动 Java 虚拟机并运行 `myprogram.jar` 中指定的 `Main-Class`。

注意：如果您的应用程序依赖于其他 JAR 文件或类文件，需要在运行 JAR 文件时通过 `-classpath` 或 `-cp` 参数指定这些依赖项。例如：

```
java -classpath library.jar -jar myprogram.jar
```



## 命令用法

`java` 和 `javac` 是 Java 开发者在命令行中经常使用的两个命令。`javac` 是 Java 编译器，用于将 Java 源代码文件编译成 Java 字节码文件（`.class` 文件）。`java` 命令用于启动 Java 虚拟机（JVM），加载和执行 Java 程序。

下面是一些`java` 和 `javac` 命令常用用法：

**javac 命令：**

1. 编译单个 Java 源文件：
   ```
   javac Main.java
   ```
   这个命令将 `Main.java` 源文件编译成 `Main.class` 字节码文件。

2. 编译多个 Java 源文件：
   ```
   javac Main.java Test.java
   ```
   这个命令将同时编译 `Main.java` 和 `Test.java` 源文件。

3. 编译指定目录下的所有 Java 源文件：
   ```
   javac -sourcepath ./src -d ./bin ./src/**/*.java
   ```
   这个命令将编译 `src` 目录下的所有 Java 源文件，并将生成的 `.class` 文件存放到 `bin` 目录下。

4. 指定编译时的类路径：
   ```
   javac -classpath lib/* Main.java
   ```
   这个命令将在编译 `Main.java` 时使用 `lib` 目录下的所有 JAR 文件作为类路径。**如果用了这个命令我们在执行java的时候也要指定classpath路径**

> 使用javac的时候,依赖的库只需要是.class文件, 但是他会去对比.class文件与.java文件的日期,如果.class文件旧与.java文件,他会把java文件也编译了

**java 命令：**

1. 执行 Java 程序：
   ```
   java Main
   ```
   这个命令将运行 `Main.class` 文件中的 `main` 方法。

2. 指定运行时的类路径：
   ```
   java -classpath lib/* Main
   ```
   这个命令将在执行 `Main` 类时使用 `lib` 目录下的所有 JAR 文件作为类路径。

3. 设置 Java 虚拟机启动参数：
   ```
   java -Xms128m -Xmx512m Main
   ```
   这个命令将在启动 Java 虚拟机时设置初始堆内存为 128 MB，最大堆内存为 512 MB。

4. 启动带有命令行参数的 Java 程序：
   ```
   java Main arg1 arg2 arg3
   ```
   这个命令将把 `arg1`、`arg2` 和 `arg3` 作为命令行参数传递给 `Main` 类的 `main` 方法。

这些是 `java` 和 `javac` 命令的一些常用选项。实际上，这两个命令还有许多其他选项和功能，您可以在官方文档中找到更详细的信息。



## 相关概念

让我们详细讨论 Java 中的包、类路径和执行机制。

1. 包（Package）：
   
   **包是 Java 中用于组织和分类类的一种方式。包名的目的是为了避免命名冲突和提高代码的可读性**。**Java 包名通常遵循域名的反序**，例如：`com.example.myapp`。包名对应的目录结构是以点（`.`）分隔的子目录，如：`com/example/myapp`。

2. Java 源文件和类文件的组织：

   在 Java 项目中，源文件（`.java`）和类文件（`.class`）通常按照包名的目录结构进行组织。例如，包名为 `com.djm.test` 的源文件应位于 `src/com/djm/test` 目录下。编译后的类文件通常放在一个单独的目录中，如 `out/com/djm/test`。

3. 类路径（Classpath）：

   类路径是 Java 运行时用于查找类文件的路径设置。Java 运行时会根据类路径的设置在文件系统或其他位置查找 `.class` 文件。类路径可以通过设置环境变量 `CLASSPATH` 或使用命令行选项 `-cp` 或 `-classpath` 来指定。

   默认情况下，类路径包含当前目录（`.`）。这意味着，如果没有指定类路径，Java 运行时会从当前目录开始查找类文件。

4. 执行 Java 程序：

   当使用 `java` 命令执行 Java 程序时，需要提供主类的全名（包括包名和类名）。例如，如果主类 `Main` 位于 `com.djm.test` 包中，执行命令应该是 `java com.djm.test.Main`。

   如果类路径设置正确，Java 运行时会在类路径中查找主类的 `.class` 文件。如果找不到主类，会报错。

**所以我们在执行java命令的时候 一定要指明包名和类名**, 根据包名我们就应该要知道我们要在哪个位置执行java命令,比如我有个java文件,设置包名为 com.djm.test  那么我门就要在这个文件的上4层目录下执行,这个目录还具有com/djm/test子目录,所以我们不要随便设置包名,而是要根据项目所在位置下面 的目录文件命名,然后再项目目录下执行文件

## 关于classpath

`classpath`（类路径）是 Java 运行时环境用来查找类和其他资源的一个参数。当 Java 运行时环境需要加载类或资源时，它会根据 `classpath` 中的设置在文件系统或其他位置查找对应的文件。`classpath` 可以包含目录、JAR 文件或其他资源。以下是 Java 会选择的几个默认类路径：

1. **当前目录**：默认情况下，Java 运行时环境会将当前目录（`.`）包含在类路径中。这意味着 Java 会在运行程序的当前目录中查找类和资源。

2. **Java 标准库**：Java 运行时环境还会在 Java 标准库（JRE 或 JDK 中的 `lib` 目录）中查找类和资源。这些库包含 Java 标准类，如 `java.util.ArrayList`、`java.lang.String` 等。

3. **用户定义的类路径**：用户可以通过设置 `CLASSPATH` 环境变量或使用命令行选项 `-cp` 或 `-classpath` 来定义自己的类路径。例如：

   ```
   java -cp /path/to/my/classes:/path/to/my/libs/mylib.jar MyMainClass
   ```

   在这个例子中，Java 会在 `/path/to/my/classes` 目录和 `/path/to/my/libs/mylib.jar` JAR 文件中查找类和资源。**使用了自定义的类路径后,当前目录就不会被加入到类路径中**

   > java标准库的优先级是高于默认和自定义的类路径的,只要在最前面找到了class文件,就不会继续往后面找

需要注意的是，不同操作系统中，类路径的分隔符可能不同。在 Windows 中，类路径的分隔符是分号（`;`），而在 Unix 和类 Unix 系统（如 Linux 和 macOS）中，类路径的分隔符是冒号（`:`）。

总之，Java 会根据当前目录、Java 标准库和用户定义的类路径设置来确定类路径。当需要加载类或资源时，Java 会根据这些设置在文件系统或其他位置查找对应的文件。

## java 命令执行流程

当使用 `java` 命令执行 Java 程序时，Java 运行时会执行以下步骤：

1. 加载 Java 虚拟机（JVM）：首先，Java 运行时会加载 Java 虚拟机，它负责执行 Java 字节码。
2. 设置类路径：Java 运行时会设置类路径（classpath），这是一个包含 Java 类文件（如 `.class` 文件）的目录和文件列表。类路径是 Java 运行时用于查找类文件的路径设置。
3. 加载主类：Java 运行时会尝试在类路径中查找指定的主类（包括包名和类名）。例如，如果执行的命令是 `java com.djm.test.Main`，Java 运行时将在类路径中查找 `com.djm.test.Main` 类,也就是 在类路径下com/djm/test/下找到 Main.class,如果找不到就会报错,**找到后会验证Main.class的包名是否跟执行包名一样**,不一样也会报错
4. 链接：链接过程包括验证、准备和解析三个阶段。验证确保类文件的结构和约束符合 Java 虚拟机规范；准备阶段为类变量分配内存并设置默认初始值；解析阶段将类中的符号引用解析为直接引用。
5. 初始化：Java 运行时会初始化类，这包括执行类的静态初始化代码（例如静态变量的初始化和静态代码块）。
6. 执行主方法：Java 运行时会找到主类中的 `main` 方法（它必须具有 `public static void main(String[] args)` 的签名），并执行它。这是 Java 程序的入口点。
7. 执行程序：`main` 方法开始执行，程序按照您编写的代码逻辑进行运行。
8. 垃圾回收：Java 程序在运行过程中，Java 虚拟机会自动进行垃圾回收，回收不再使用的对象占用的内存。
9. 程序结束：当 `main` 方法执行完毕或者调用了 `System.exit()` 方法，Java 程序结束，Java 虚拟机关闭，释放相关资源。

这些步骤概括了使用 `java` 命令执行 Java 程序的整个过程。在这个过程中，Java 运行时负责管理内存、执行字节码和处理异常等任务。

## jdk jre jvm

JDK（Java Development Kit）、JRE（Java Runtime Environment）和 JVM（Java Virtual Machine）是 Java 平台的三个核心组成部分。它们之间存在联系，但也有区别。下面我们详细讨论这三个组件：

1. JVM（Java Virtual Machine）：
   - Java 虚拟机是 Java 平台的基础，它为 Java 字节码提供了一个运行时环境。JVM 负责将 Java 字节码（.class 文件）翻译成与特定硬件和操作系统相对应的本地机器代码。
   - JVM 是平台无关的，不同的操作系统和硬件平台都有相应的 JVM 实现。这使得 Java 应用程序能够跨平台运行（“一次编写，到处运行”）。
   - JVM 还负责管理 Java 程序的内存分配和垃圾回收。

2. JRE（Java Runtime Environment）：
   - Java 运行时环境包括 JVM 以及 Java 类库（java.util、java.lang、java.io 等）和其他运行 Java 应用程序所需的文件。
   - JRE 允许用户在没有安装 JDK 的情况下运行 Java 程序。这意味着用户只需要 JRE 就可以运行 Java 应用程序，而无需 JDK。
   - JRE 不包括开发工具，如编译器（javac）或调试器。因此，如果要开发 Java 程序，需要 JDK。

3. JDK（Java Development Kit）：
   - Java 开发工具包是 Java 开发人员使用的完整软件开发包，包括 JRE、编译器（javac）、调试器、文档生成器（javadoc）以及其他开发和调试 Java 程序所需的工具。
   - JDK 是开发 Java 应用程序所需的最低要求。它包含了 JRE，因此安装 JDK 时，无需单独安装 JRE。

总结一下：
- JVM 是 Java 虚拟机，提供了运行 Java 字节码的环境，并负责内存管理和垃圾回收。
- JRE 是 Java 运行时环境，包括 JVM 和 Java 类库，用于运行 Java 程序。
- JDK 是 Java 开发工具包，包括 JRE 和开发工具（编译器、调试器等），用于开发 Java 程序。

JDK、JRE 和 JVM 之间的关系是：JDK 包含 JRE，JRE 包含 JVM。在 Java 开发和运行过程中，这三者共同协作，使得 Java 程序能够跨平台运行。

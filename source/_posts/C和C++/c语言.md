---
title: c语言学习
date: 2023-6-12
tags:
  - c语言
  - 需要复习
---

# 前言

两年前学的c语言,好久没用了, 忘得差不多了, 现在重新学习一下,用博客记录下来,常回来复习复习



# 预处理器

## 定义

在C语言中，预处理器（preprocessor）是一个在**编译阶段前执行的程序**，它可以对源代码做一些预处理工作。预处理器通过预处理指令（preprocessor directives）来完成这些工作，预处理指令都以`#`符号开头。

以下是一些常见的预处理指令：

1. **#include**：这个指令用于包含头文件。例如，`#include <stdio.h>`会在当前源代码文件中插入stdio.h头文件的内容。这样，我们就可以使用在stdio.h中定义的函数和宏了。

2. **#define**：这个指令用于定义宏。**宏可以看作是一个文本替换工具**，预处理器会在编译前将所有宏替换为其定义的内容。例如，`#define PI 3.14`定义了一个宏PI，预处理器会把源代码中所有的PI替换为3.14。

3. **#undef**：这个指令用于取消已定义的宏。例如，`#undef PI`会取消PI宏的定义，之后的代码就不能使用PI宏了。

4. **#if, #else, #elif, #endif**：这些指令用于条件编译。预处理器会根据条件来决定是否编译某段代码。例如：

   ```c
   #define DEBUG 1
   ...
   #if DEBUG
   printf("Debug information...\n");
   #endif
   ```

   如果DEBUG被定义为1，那么printf语句会被编译和执行。如果DEBUG被定义为0，那么printf语句会被忽略。

5. **#ifdef, #ifndef**：这些指令也用于条件编译，但它们检查的是某个宏是否已被定义。例如，`#ifdef DEBUG`会检查DEBUG宏是否已定义，如果已定义，就编译随后的代码。

预处理器还有一些其他的功能，如错误处理、源文件包含等。预处理器的作用虽然不如编译器和链接器显著，**但它在处理源代码、改善代码复用性、模块化等方面起着重要作用。**

## 功能

预处理器的主要功能包括：

1. **文件包含（Inclusion of Files）**：预处理器通过`#include`指令包含头文件。这使得程序员可以将程序的各个部分分开在不同的文件中编写，并通过这个功能将他们链接在一起。
2. **宏替换（Macro Replacement）**：预处理器通过`#define`指令定义宏，然后在程序中替换这些宏。这是一种非常有效的方式来定义程序中要使用的常量。**这个东西非常好用,很多框架也在用, 这个能帮我们少写很多代码, 所以看起来他就是个文本替换工具**
3. **条件编译（Conditional Compilation）**：预处理器通过`#if`，`#elif`，`#else`和`#endif`等指令进行条件编译。这使得程序员可以根据特定的条件选择性地编译代码的一部分。
4. **编译错误和警告的处理**：预处理器可以通过`#error`和`#warning`指令来发出编译错误和警告。这对于程序调试非常有用。
5. **行控制（Line Control）**：预处理器通过`#line`指令来控制`__LINE__`和`__FILE__`这两个内置宏的值。这使得程序员可以控制在错误报告中显示的行号和文件名。
6. **定义判断**：预处理器通过`#ifdef`，`#ifndef`和`#undef`指令来判断一个宏是否已经定义，并据此决定是否编译某部分代码。

通过以上功能，预处理器为C语言提供了丰富的编程灵活性，有助于模块化编程，提高代码复用性，使得源代码更易于阅读和维护。

举个例子吧

```c
#include <stdio.h>

#ifdef __AAA_AAA_
你好啊, 我不会被编译
#endif

#if _AAA_AAA_
我也不会被编译
#endif

// ifdef 和 if的区别在于  if是检查后面这个东西有没有被定义和它的值是不是真,  而infdef是看后面这个东西有没有被定义
int main()
{
    #if 1
        printf("我会被编译");
    #endif
    return 0;
}
```

使用gcc预编译一下可以发现确实如此

![image-20230615193432089](../../img/c语言assets/image-20230615193432089.png)

## #define

这个东西太好用了,以至于要单独拿一个部分出来总结

`#define`是C语言预处理器中的一个非常有用的指令，主要用于定义宏（macros）。它可以有两种基本形式：对象式宏（object-like macros）和函数式宏（function-like macros）。

1. **对象式宏**：这是最简单的宏定义形式，它将一个名称定义为一个特定的值。例如：

    ```c
    #define PI 3.14159
    ```
   在这个例子中，PI就被定义为3.14159。在预处理阶段，预处理器会将代码中所有的PI替换为3.14159。

2. **函数式宏**：函数式宏可以带有参数，看起来更像一个函数。例如：

    ```c
    #define SQUARE(X) ((X) * (X))
    ```
   在这个例子中，SQUARE就被定义为一个计算其参数平方的宏。使用SQUARE(2)会被预处理器替换为((2) * (2))，结果是4。

这些宏在预处理阶段就已经展开并替换，**所以它们不会像函数那样带来调用的开销**。但是，过度使用宏可能会导致代码难以阅读和理解，因为宏只是简单的文本替换，不会进行类型检查。



### 高级方法

#### 定义for循环

这个是不可以很好减少我们写for循环?

```c
#define FI(n) for(int i = 0; i < n; i++)
#define FJ(n) for(int j = 0; j < n; j++)
```

#### 定义多行宏

有时候把后面的东西写在一行有点难受,我们可以用\换行, 但是在代码中还是一行

```c
#define F(n1,n2) for(int i = 0; i < n1; i++) \
 for (int j = 0; j < n2; j++) \
```



#### 参数类型宏

**宏的参数可以出现类型**(其实也就是字符串替换), 因此我们是不是可弄一个好用的malloc

```c
#define MALLOC(n, type) (type*)malloc(n * sizeof(type))

int* nums = MALLOC(10, int);
```



#### \# \#\# \#@

在用#define 定义时 , 斜杠("\\")是用来续行的，"#"，是给参数加上双引号。"##"则用来连接前后两个参数 ,"#@"是给参数加上单引号, 

```c
#define toString(str)  #str
#define CONCATENATE(a, b) a ## b

int CONCATENATE(num, 1) = 10;  // 创建一个变量 num1   替换后就是 int num1 = 10
print("%s",toString(123));  //很方便的将一个数字变成字符串,但是要注意,这里填变量也会变成字符串
print("%s",toString(num1));  //这里输出就是 num1这个字符串
```



在使用`#define`时，你应当注意到一些常见的问题。首先，因为预处理器只是进行文本替换，所以可能会出现预期外的效果。例如，**函数宏中的参数如果不用括号包围，可能会因为运算符优先级的问题导致错误**。其次，过度使用宏可能会使代码变得难以理解和维护。尽管宏可以提供强大的功能，但应当谨慎使用。

注意点:

* 宏不能递归 \#define func(a, b)  func(a,b)  比如这个, 宏只会替换一次,  但是宏可以嵌套
* **宏的参数可以出现类型，但是函数做不到**
* 参数的副作用  比如 a++ 这种就尽量不要成为宏的参数
* 宏产生的代码是不能调试的

**最后请记住宏就是个文本工具**

# **数据类型**

## 定义

C语言中的数据类型是用于声明变量或函数的关键部分。一个数据类型定义了一种数据的范围和特性。C语言主要有以下几种数据类型：

1. **基本数据类型**：C语言有四种基本数据类型：
   - **整型(int)**：用于表示无小数的数，包括正整数、负整数和0。还有短整型（short）、长整型（long）和长长整型（long long）等更具体的类型。
   - **浮点型(float)**：用于表示有小数的数，例如3.14、0.1234等。
   - **双精度浮点型(double)**：比浮点型具有更高的精度，适用于需要极高精度的计算。
   - **字符型(char)**：用于表示单个字符。

2. **派生数据类型**：由基本数据类型派生出的数据类型，包括：
   - **数组(Array)**：存储相同类型数据的有序集合。
   - **指针(Pointer)**：指针类型是一种特殊的数据类型，它存储的是其他数据类型的内存地址。
   - **结构体(struct)**：结构体是一种聚合数据类型，可以包含不同类型的数据。
   - **联合体(union)**：联合体是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。它只能存储一种类型的数据，但可以是任意类型。
   - **枚举(enum)**：枚举是一种用户自定义的数据类型，它允许你将一组整数值赋予有意义的名字，以提高程序的可读性。

3. **void类型**：void类型表示没有值。这是一种特殊的数据类型，**通常用于定义无返回值的函数和没有参数，或者空指针**。

**每种数据类型都有其特定的取值范围和存储需求，这些都依赖于你所使用的系统和编译器**。

C语言还允许定义自己的数据类型，通常通过typedef关键字实现。例如，可以通过typedef创建一个新的数据类型名，然后使用这个新的数据类型名来定义变量。

在编写程序时，选择适当的数据类型非常重要，因为它会影响数据如何被存储在内存中，以及如何使用这些数据。

## 常用数值范围宏

在C语言中，可以通过在<limits.h>和<float.h>这两个头文件中定义的一些宏来获取各种数据类型的最大值和最小值。这些值可能会因编译器或平台的不同而有所不同，但通常符合特定的标准。

以下是一些常见数据类型的最大值和最小值的宏：

1. **整数类型（包括short、int、long、long long）**：可以通过以下宏来获取：
   - `INT_MIN` / `INT_MAX`：int类型的最小值和最大值。
   - `LONG_MIN` / `LONG_MAX`：long类型的最小值和最大值。
   - `SHORT_MIN` / `SHORT_MAX`：short类型的最小值和最大值。
   - `LLONG_MIN` / `LLONG_MAX`：long long类型的最小值和最大值。
2. **字符类型（char）**：
   - `CHAR_MIN` / `CHAR_MAX`：char类型的最小值和最大值。
3. **浮点类型和双精度浮点类型（float、double）**：可以通过以下宏来获取：
   - `FLT_MIN` / `FLT_MAX`：float类型的最小正值和最大正值。
   - `DBL_MIN` / `DBL_MAX`：double类型的最小正值和最大正值。

在使用这些宏之前，需要包含对应的头文件，例如：

```c
#include <limits.h>
#include <float.h>
```

## 常量

在 C 语言中，常量（constants）是固定值，它们在程序运行过程中不能被修改。常量可以是任何基本数据类型，例如整数常量、浮点常量、字符常量，还有字符串字面量等。常量必须在定义的时候就初始化好, 不然会报错





## 类型转换

在C语言中，类型转换用于将一种数据类型转换为另一种。类型转换有两种基本形式：隐式类型转换（也称为自动类型转换）和显式类型转换（也称为强制类型转换或类型强制转换）。

1. **隐式类型转换**：当我们进行不同数据类型的混合运算时，编译器会自动进行类型转换。这种类型转换是隐式的，即程序员无需明确指定。在这种情况下，较小的数据类型会被转换为较大的数据类型。例如，如果你将一个`int`类型和一个`double`类型的值进行加法运算，`int`值会被自动转换为`double`类型，然后进行运算。

2. **显式类型转换**：有时候，我们需要手动进行类型转换，这称为显式类型转换，或者称为强制类型转换。在C语言中，可以通过将目标类型放在括号中，并放在要转换的变量或表达式前面来实现。例如，如果你想将`double`类型的变量转换为`int`类型，可以这样做：`int x = (int) y;`，其中`y`是一个`double`类型的变量。

值得注意的是，类型转换可能会引起数据丢失或溢出。例如，如果你将一个`double`类型的值强制转换为`int`类型，小数部分将会被丢弃。如果你将一个超过`int`范围的`long`类型的值强制转换为`int`类型，可能会导致数据溢出。

最后，C语言还有一种特殊的类型转换，叫做类型提升。当较小的整数类型（如`char`或`short`）用作算术表达式的一部分时，它们会被提升为较大的整数类型（通常是`int`）。这是C语言为了运算效率和结果精度做的一种优化。

# 存储类别说明符

`static`, `extern`, 和 `const` 在 C 语言中被称为存储类别说明符（Storage Class Specifiers）。它们用于指定变量、函数或声明的范围（可见性）、生命周期、以及是否可以被修改。

让我们来看一下这些存储类别说明符的意义：

1. **static**：在变量和函数前使用 `static` 关键字，**会使得它们的作用域局限于声明它们的源文件内, 跨.cpp和.c文件是无法共享和使用的**。对于局部变量，`static` 也改变了它们的生命周期，使得它们在程序的整个运行期间都存在，而不仅仅是在声明它们的函数或代码块执行时存在。

2. **extern**：`extern` 关键字用于声明一个变量或函数在别的源文件中已经被定义。这样，这个变量或函数就可以在其他文件中被使用，即使它是在另一个源文件中定义的。

3. **const**：`const` 关键字用于指定一个变量的值不能被修改（即，这个变量是只读的）。这对于防止无意的修改非常有用，也可以让编译器进行一些优化。

除了这三个关键字，C 语言中还有其他的存储类别说明符，如 `auto` 和 `register`。不过，`auto` 是默认的，不常显式地用在代码中，`register` 关键字的作用在现代编译器中已经基本被忽视。

## static

在 C 语言中，`static`关键字有几个不同的用途，具体取决于它的使用环境：

1. **静态局部变量**

    当 `static` 关键字用于函数内部的变量时，它改变了该变量的存储期。通常情况下，函数内的局部变量在函数被调用时创建，函数返回时销毁。但如果局部变量被声明为 `static`，则其生命周期在程序运行时始终存在。这意味着，当函数被多次调用时，静态局部变量的值在调用之间保持不变。

    ```c
    void foo() {
        static int count = 0;
        count++;
        printf("%d\n", count);
    }
    ```
   这个例子中，`count` 变量每次调用 `foo` 函数时都会增加。但是你在外界是无法访问的

2. **静态全局变量**

    如果 `static` 关键字用于函数外部的变量，它限制了该变量的链接作用域（linkage）到定义它的文件。换句话说，`static` 全局变量只能在定义它的源文件中访问，其他源文件不能访问。

    ```c
    // file1.c
    static int count = 0;  // This variable is only accessible within file1.c
    ```

3. **静态函数**

    和静态全局变量类似，`static` 也可以用于函数，使得函数只能在定义它的源文件中访问。

    ```c
    // file1.c
    static void foo() {  // This function is only accessible within file1.c
        // ...
    }
    ```

`static` 关键字使你能够控制变量和函数的可见性，从而更好地封装代码。此外，静态局部变量还允许你保持在函数调用之间保持状态，而不必使用全局变量。

# 从源代码到可执行文件

编译器在编译源代码的过程中，会经过几个步骤：预处理、编译、汇编和链接。

1. **预处理**：预处理器处理源代码中的 `#include`、`#define` 等预处理指令。当你在 C 代码中使用 `#include` 指令时，预处理器会将这个头文件的全部内容复制到源文件中。**这一步并不涉及编译，只是文本处理**。
2. **编译**：**编译器将预处理后的源代码转换成汇编语言**。
3. **汇编**：汇编器将编译器生成的汇编语言转换成目标文件，**也就是机器代码**。
4. **链接**：**链接器将所有的目标文件和需要的库链接成一个可执行文件**。在这个过程中，链接器需要解决外部符号（extern）的引用问题，也就是确定这些符号的具体位置。

这个四个步骤对应的命令

```
gcc -E test.c -o test.i       # 预处理
gcc -S test.i -o test.s       # 编译
gcc -c test.s -o test.o       # 汇编
gcc test1.o test2.o -o output # 链接
```

在这里我们就可以解释extern的作用了

在 C 语言中，`extern` 关键字用于**声明一个变量或函数，而不是定义它**。这意味着我们在一个文件中声明一个变量或函数，可以在其他文件中使用它。

**当我们在一个源文件中定义一个全局变量或函数**，其他源文件中使用这个变量或函数的文件就必须通过 `extern` 来声明它的存在(当然,如果是在头文件里面,你也可以通过include)。实际的定义只能在一个源文件中进行，声明可以在多个文件中进行。

>  当然,你也是可以不用extern关键字, 然后再别的地方做声明,  但是这个让别人不好区分,会很容易产生迷惑,  不过这个也看链接器的行为,  我的建议如果不是使用引入头文件的方式的话, 就都写上extern 

举个例子吧

这个是test2.c

```
#include<stdio.h>
void sayHello(){
    printf("hello world\n");
}
int a = 10;
```

里面定义了一个函数和变量,但是我希望外部使用,这个是test.c

```
#include <stdio.h>
// #include "test2.c"  我们这里也可以使用include的方式

extern void sayHello();
extern int a;

int main()
{
    printf("hello world\n");
    printf("a = %d\n", a);
    return 0;
}

```

如果是使用include的方式的话,那么是可以直接编译test.c运行的,  但是如果是使用extern的方式的话,还得编译test2.c 然后链接起来就可以了

这里又引出了一个点:  **.h文件是不是简化了我们的代码, 让我们少用了extern关键字**,

# 头文件和源文件

在 C 语言中，`.h` 和 `.c` 文件在编译过程中的作用主要有以下几点：

1. **头文件（.h）**：头文件主要用于**声明**函数、变量和类型。通过这些声明，你可以在其他文件中使用这些函数、变量和类型，即使它们在其他文件中定义。通常，你会在头文件中声明函数和全局变量，然后在一个源文件中定义它们。这样，其他源文件就可以通过包含相应的头文件来使用这些函数和全局变量。**头文件最终是会被展开在每一个引入它的源文件中的**, 所以我们最终还是要看源文件
2. **源文件（.c）**：**源文件用于定义函数和全局变量**。这是编译器真正需要去编译的代码。每个源文件通常会包含一个或多个函数和全局变量的定义。在编译过程中，编译器会为每个源文件生成一个目标文件（.o 文件）。

头文件通过 `#include` 指令被包含在源文件中。当编译器看到 `#include "file.h"` 指令时，它会将 "file.h" 的内容插入到源文件中，然后继续编译。这样，源文件就可以访问在 "file.h" 中声明的函数和全局变量。

在链接阶段，链接器会将所有的目标文件链接在一起，形成一个可执行的程序。**链接器需要确保每个函数和全局变量只被定义一次**，否则会出现链接错误。这就是为什么你不能在多个源文件中定义同一个函数或全局变量。 **所以说,我们尽量只在头文件里面做声明,不要做定义**, 因为头文件引入后会把里面的变量一起带过来, 但是如果不是static这种存储类别的话, 那肯定就都是全局变量,那这不就乱套了吗? 但是函数声明和变量声明是可以在.h文件里面声明的

总的来说，头文件（.h）用于声明，源文件（.c）用于定义。在编译阶段，编译器编译源文件；在链接阶段，链接器将目标文件链接在一起，形成一个可执行的程序。



# 补充

## 变量声明位置

**在 C99（1999年发布的C语言标准）及以后的版本中，你可以在代码的任何位置声明和定义变量**。在此之前的C89/C90标准中，变量必须**在代码块或函数的开头被声明**。

举个例子，在C89/C90中，你需要这样做：

```c
void func() {
    int i;
    for(i = 0; i < 10; i++) {
        printf("%d\n", i);
    }
}
```

而在C99及以后的版本中，你可以这样做：

```c
void func() {
    for(int i = 0; i < 10; i++) {
        printf("%d\n", i);
    }
}
```

在这个例子中，变量`i`就在`for`循环的初始化部分被声明和定义。

如果你不确定自己的编译器支持哪个版本的C语言，你可以查阅编译器的文档或者在线搜索相关信息。对于GCC和Clang这类编译器，你可以使用命令行参数`-std=c99`（或者更新的版本，如`-std=c11`，`-std=c17`等）来指定C语言的版本。
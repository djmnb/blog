---
title: 数据结构
date: 2023-6-27
tags:
  - 数据结构
  - 需要复习
---

# 前言

趁着考研的机会,好好学一下,  所用语言是c/c++

# 基本概念

**程序 = 数据结构 + 算法**

* 数据:  **数据是信息的载体**, 是描述客观事物属性的数,字符及能被输入到计算机中处理的符号.  **数据是计算机加工的原料**
* 数据元素: **数据元素是数据的基本单位, 通常作为一个整体进行考虑和处理, 一个数据元素是由多个数据项组成的**, 比如 一个学生就是一个数据元素  它由学号,姓名, 性别等数据项组成
* 数据项: **数据项是构成数据元素的不可分割的最小单位**
* 数据对象: **具有相同性质的数据元素的集合**
* 数据结构: **数据元素相互之间存在一种或多种关系的集合**
* 数据类型: 原子类型(值不可再分), 结构类型(值可以再分,类似结构体), 抽象数据类型(定义数据的逻辑结构与其相关操作), **抽象数据类型相当于定义了整个数据结构**

数据对象和数据结构的区别:   数据对象是**所有相同性质**的数据元素的集合   而且 数据结构是 **具有相同性质 且 相互之间有关系**的数据元素集合,   比如说  所有学生都在同一个数据对象里面,  但是排名前一百的学生在一个数据结构里面也就是线性表里面,  

## 数据结构的三要性

在计算机科学中，数据结构的三要素通常指：数据的逻辑结构、数据的存储结构（也称物理结构）以及数据的操作。

1. **数据的逻辑结构**：逻辑结构是指数据对象中数据元素之间的相互关系。**这个关系是对具体问题的抽象，与数据的存储无关**。根据元素之间的关系，逻辑结构可以分为线性结构、树结构、图结构以及集合。
   - **线性结构**：数据元素之间存在一对一的关系。例如：数组、链表、栈、队列等。
   - **树结构**：数据元素之间存在一对多的关系。例如：二叉树、B树、红黑树等。
   - **图结构**：数据元素之间存在多对多的关系。例如：图、网络等。
   - **集合**：**数据元素之间没有明显的关系**。
   
2. **数据的存储结构**：存储结构是指数据对象在计算机内存中的组织方式，也称为物理结构。主要有顺序存储和链式存储。

   - **顺序存储结构**：数据元素存储在连续的存储单元里，物理上的相邻也代表逻辑上的相邻。这种方式典型的如数组。
   - **链式存储结构**：数据元素可以存储在内存的任意位置，通过链接（如指针）来建立数据元素之间的逻辑关系。这种方式典型的如链表。
   - **索引存储结构**：索引存储结构是在存储元素信息的同时，还创建一种索引表，索引表中包含对主文件中数据元素的引用。通过索引，可以实现对数据的快速访问。(索引表是一般是线性结构, 一般有个键和值  键可以代表唯一的数据元素 值是数据元素的地址)
   - **散列存储结构**：散列存储，也叫哈希存储，它是根据元素的关键字直接进行访问的。通常会有一个哈希函数将关键字映射到一个地址上。

3. **数据的运算**：**这是定义在特定数据结构上的一系列处理数据的方法或者函数**，这些操作可以是查找、插入、删除、排序等。这些操作要满足可行性（即算法的正确性）和有效性（即算法的高效性）。  **运算的定义是针对逻辑结构, 运算的实现是针对存储结构**

这三者相互关联，逻辑结构决定了数据的运算，而存储结构则是逻辑结构和数据运算在计算机中的实现基础。理解并掌握这三个要素，是理解和应用数据结构的关键。

## 算法

算法是**解决特定问题的一系列明确的执行步骤**。它是从输入开始，按照一定规则和步骤，经过有限次运算后，得到预期结果的过程。

算法具有以下五个基本特性：

1. **有穷性**：算法必须能在执行有限步骤之后结束，不能无限制地执行下去。

2. **确定性**：算法的每一步必须清晰明确，没有歧义, **对于相同的输入只能得到相同的输出**。

3. **可行性**：算法中描述的操作都是可以通过已经实现的**基本操作执行有限次**来实现。

4. **输入**：一个算法有零个或多个输入。

5. **输出**：一个算法至少有一个或多个输出，即算法的执行结果。

   

在计算机科学中，算法是非常重要的概念。一个好的算法不仅能正确解决问题，还应该尽可能地优化时间复杂度和空间复杂度，使得在处理大规模数据时仍能保持良好的性能。算法的设计和分析是计算机科学的核心内容之一，也是计算机程序设计的关键。

一个好的算法通常需要满足以下五个特性：

1. **正确性**：算法应能正确地解决所指定的问题，对于合法的输入数据，应能得到满足要求的输出结果。此外，对于非法的、异常的输入数据，算法应做出相应的处理。

2. **可读性**：算法应清晰、简洁，易于人理解，这样便于其他人员阅读、修改和维护。

3. **健壮性**：算法需要对各种异常输入或者错误情况进行有效处理，使其在面对这些情况时不会崩溃或产生未预期的结果。

4. **效率和存储量需求**：优秀的算法应具有尽可能低的时间复杂度和空间复杂度。在处理大量数据时，算法的效率尤为重要。同时，算法应尽量节省存储空间，减小对计算资源的消耗。

5. **可扩展性和可复用性**：一个好的算法应具有良好的扩展性，能处理比现有需求更大或更复杂的问题。同时，如果算法具有一定的通用性，那么在其他场景或问题中也可能复用，从而提高编程效率。

以上这些特性并不是孤立的，而是相互关联的。例如，为了提高效率，我们可能需要牺牲一些可读性；为了增加健壮性，我们可能需要增加一些错误处理的代码，这可能会影响效率。因此，在设计算法时，我们需要根据具体情况进行权衡和选择。

## 时间复杂度

算法的时间复杂度是一种**衡量算法运行时间长短的量化指标**。它反映了随着输入数据规模的增大，算法执行时间的增长趋势。通常，**我们关注的是最坏时间复杂度**，因为它代表了算法在最糟糕情况下的执行时间。

时间复杂度的计算通常关注的是算法中基本操作的执行次数，而忽略了具体的硬件条件和运行环境等因素。我们通常用大O符号（O）来表示时间复杂度，**大O符号表示的是问题规模n与算法执行时间增长率的上界关系**, **只保留了最高阶的部分,系数也不考虑**。

下面是一些常见的算法时间复杂度，从低到高排列：

1. 常数阶O(1)
2. 对数阶O(logn)
3. 线性阶O(n)
4. 线性对数阶O(nlogn)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. K次方阶O(n^k) (k>3)
8. 指数阶O(2^n)
9. 阶乘阶O(n!)
10. 双阶乘阶O(n!!)
11. 指数阶O(n^n)

理解时间复杂度对于编程和算法分析都非常重要，它可以帮助我们预测算法的运行效率，并在多种算法之间做出合理的选择。

**这里需要注意的是  无论时间复杂度是多少,  问题规模是 n 而不是 O(n)**, 问题规模是指n的数量

## 空间复杂度

空间复杂度是对一个算法在运行过程中**临时占用存储空间大小的量度**，它也是算法效率评价的重要指标之一。空间复杂度过高的算法可能会导致使用的内存超出硬件限制，导致程序无法正确运行。

空间复杂度的计算同样也是基于大O符号表示的，表示随着数据规模的增长，算法的存储空间需求如何变化。

## 



# 线性表(有序表)

线性表是一种基本的数据结构，**它是由n个具有相同特性的数据元素组成的<span style="color:red">有限序列</span>**。

线性表的特点是数据元素之间存在一对一的线性关系，也就是除首尾元素外，其他元素都有<em style="color:red">唯一的前驱和后继</em>。

线性表是一种基本的数据结构，具有以下几个主要特点：

1. **有限性**：线性表是由有限个数据元素组成的。

2. **有序性**：线性表中的元素之间有明确的前后顺序关系。每个元素（除第一个元素外）都有唯一的直接前驱，每个元素（除最后一个元素外）都有唯一的直接后继。

3. **同质性**：线性表中的所有元素都具有相同的数据类型或结构。

4. **相互独立**：线性表中的元素之间是相互独立的，元素的变化只与其本身有关，不受其他元素的影响。

5. **可变性**：线性表可以进行插入、删除、查找等操作，元素的个数和内容可以改变。

线性表有两种常见的实现方式：数组和链表。

1. **数组**：数组是一种连续的存储结构，它的特点是支持随机访问，也就是说，可以在常数时间内访问任何位置的元素。但是数组的大小在创建时就已经固定，所以不能动态改变。此外，数组中的元素在内存中是连续存储的，所以在插入和删除元素时需要移动大量的元素，效率较低。

2. **链表**：链表是一种非连续的存储结构，它的特点是插入和删除操作的效率很高，只需要改变一些指针的指向就可以了。但是链表不支持随机访问，访问某个元素需要从头开始遍历链表，所以访问效率较低。链表可以动态改变大小，更加灵活。

线性表是数据结构中的基础，许多复杂的数据结构，如栈和队列，都是基于线性表实现的。理解线性表的性质和操作对于深入理解和应用数据结构非常重要。

## 顺序表

顺序表是一种常见的线性表实现方式，它将元素存储在一段连续的存储单元里，每个元素所占用的存储单元相同，元素的逻辑顺序与其在存储单元中的物理顺序一致。也就是说，如果我们知道了某一个元素的存储地址，那么我们就可以直接计算出其它元素的地址，这就是顺序表支持随机访问的原因。

**顺序表的基本操作包括：**

1. **插入**：在顺序表的特定位置插入元素。若插入位置后有元素，则需要将这些元素后移，为新元素腾出空间。

2. **删除**：删除顺序表中的某个元素。若删除位置后有元素，则需要将这些元素前移，填补空白。

3. **查找**：按照元素值或者位置进行查找。

4. **修改**：修改顺序表中某个位置的元素。

**顺序表的优点：**

1. 访问速度快，支持随机访问，时间复杂度为O(1)。

2. 结构简单，容易实现。

**顺序表的缺点：**

1. 插入和删除操作需要移动大量元素，时间复杂度为O(n)。

2. 需要一块连续的存储空间，可能会造成空间的浪费。如果存储空间不够，需要重新分配空间，操作复杂。

在实际使用中，顺序表适用于元素数量固定，且主要进行查找操作的场景。如果需要频繁地进行插入和删除操作，可能链表是更好的选择。





## 链表

### 头结点

根据是否包含头节点，链表可以分为带头节点的链表和不带头节点的链表。

带头节点的链表是指链表中的第一个节点（头节点）不存储实际的数据，只是起到一个标记的作用，方便链表的操作。

与之相反，不带头节点的链表中的第一个节点直接存储数据，并指向下一个节点。

带头节点的链表有以下优点：

1. **统一了插入和删除操作**：在带头节点的链表中，插入和删除操作可以统一进行，不需要特殊处理空链表或者头部和尾部的情况。
2. **方便处理空链表**：头节点可以作为一个特殊的标记，用来表示链表为空，这样在处理空链表时不需要额外的判断。
3. **便于链表的遍历和返回**：有了头节点，可以更容易地进行链表的遍历和返回链表的起始位置。

总的来说，带头节点的链表在操作上更加方便和统一，使得代码的编写和理解更加简单。但是，头节点也会占用一定的额外空间。是否使用头节点，取决于具体的应用场景和设计考虑。

### 头插法 和 尾插法

在链表的创建过程中，"头插法"和"尾插法"是两种常见的插入方法，用于向链表中添加新的元素。这两种方法的主要区别在于新元素添加到链表的位置。

**头插法**

头插法是将新的元素添加到链表的开头。具体操作如下：

1. 创建新的节点，并将待插入的数据放入节点中。
2. 将新节点的指针指向当前的头节点。
3. 更新头节点，使其指向新的节点。

这样，每次插入的新节点都会成为链表的头节点。因此，使用头插法创建的链表中元素的顺序与输入的顺序是相反的。

**尾插法**

尾插法是将新的元素添加到链表的末尾。具体操作如下：

1. 创建新的节点，并将待插入的数据放入节点中。
2. 找到链表的尾节点，将尾节点的指针指向新节点。
3. 更新尾节点，使其指向新的节点。

这样，每次插入的新节点都会成为链表的尾节点。因此，使用尾插法创建的链表中元素的顺序与输入的顺序是相同的。

这两种插入方法各有优缺点，具体应用哪种方法取决于具体需求。**头插法的操作更简单，但会改变元素的原始顺序**；**尾插法可以保持元素的原始顺序，但需要额外的操作来维护尾节点。**







## 循环链表









# 栈 队列  数组

## 前言

本章 通常以选择题的形式考查,  **栈和队列的实现是基于有序表的, 而且他们是受限的线性表,比如栈只能操作一端**,因此有顺序表和链表两种实现

## 栈

### 定义

栈（Stack）是一种特殊的线性数据结构，它遵循 **LIFO（Last In First Out，即后进先出）**的原则。也就是说，最后一个添加进来的元素会被首先移除。

栈的主要操作包括：

1. **Push**：添加元素到栈顶。
2. **Pop**：移除栈顶元素。
3. **Top/Peek**：查看（但不移除）栈顶元素。
4. **isEmpty**：检查栈是否为空。

栈在许多领域都有应用，例如在算法（如深度优先搜索，括号匹配），操作系统（如内存管理，函数调用堆栈），编程语言的实现（如递归函数的实现）等方面都有重要应用。

### 实现

#### 顺序表实现:

* 元素为空的判断: 栈顶指针top == -1
* 入栈  st[++top] = v
* 出栈  v = st[top--]
* 查看栈顶元素  v = st[top]

#### 单向链表实现(不带头结点):

* 元素为空的判断: 栈顶指针head == NULL
* 入栈  node->next = head ;  head = node
* 出栈  v = head.v; node = head; head=head->next; free(node)
* 查看栈顶元素  v = head.v



### 共享栈

共享栈是一种特殊的栈结构，它允许在同一个数组中实现两个栈。这种结构是通过将一个数组的两端分别作为两个栈的栈底，然后让这两个栈向中间生长来实现的。这种设计有效地利用了数组空间，避免了单栈可能导致的空间浪费。

在共享栈的实现中，通常有如下几个主要的操作：

1. **初始化**：分别设置两个栈的栈底，一个在数组的起始位置，一个在数组的末尾位置。
2. **push**：向指定的栈中添加元素。如果添加元素的栈是从数组起始位置开始的，那么新元素应被添加到当前栈顶的下一个位置；如果添加元素的栈是从数组末尾位置开始的，那么新元素应被添加到当前栈顶的前一个位置。
3. **pop**：从指定的栈中删除元素，就是将对应栈的栈顶指针向栈底方向移动一位。
4. **isEmpty**：检查指定的栈是否为空，只需要查看该栈的栈顶指针是否指向其栈底即可。

需要注意的是，当两个栈的栈顶指针相遇时，说明数组已经满了，不能再向任何一个栈中添加元素。判满条件是 topb - topa == 1

**共享栈的一个主要优点是它能有效地利用空间，避免了一端空闲，另一端溢出的情况**

### 做题方法

技巧

1. **n个元素依次进栈 得到出栈顺序个数函数** $ f(n) = \frac{C{n \choose 2n}}{{n + 1}} $

2. **出栈顺序 应该满足这样一个要求,  一个元素前面的元素如果 没有在序列前出现,  那么他们在后面出现的时候 顺序不能改变**, 这个其实就满足了, 后入栈的元素 一定要早出于 **先入栈而且还存在与栈中的元素**, 比如入栈顺序是 abcdef  这个时候 先出栈了一个 f 这个时候, 你会发现,  后面的元素顺序已经确定了 就是  fedcba 如果出栈了  af 那么 顺序就是  afedcb
3. <em style="color:red">根据第二条,  我们可以通过出栈序列计算出栈需要最小存储空间  比如入栈序列为  abcdefg,  出栈序列为 bdcfeag  我们只需要看序列当前元素后面有多少个比自己早入栈的元素: 1 2 1 2 1 0 0   因此最小存储空间为 2+1 = 3  这是因为当前比自己早入栈的元素肯定在栈中</em>

注意点:

* 顺序表中,  数组尾巴才是栈顶,切记,  所以打印数组元素的时候,  最后一个元素才是栈顶元素

## 队列

队列（Queue）是一种特殊的线性数据结构，它遵循 FIFO（First In First Out，即先进先出）的原则。也就是说，最先添加进来的元素会被首先移除。

队列的主要操作包括：

1. **Enqueue**：在队列尾部添加一个元素。
2. **Dequeue**：从队列头部移除一个元素。
3. **Front/Peek**：查看（但不移除）队列头部的元素。
4. **IsEmpty**：检查队列是否为空。
5. **IsFull**：检查队列是否已满。

队列在许多领域都有应用，例如在算法（如宽度优先搜索，缓存实现），操作系统（如任务调度，打印任务队列），编程语言的实现（如事件队列）等方面都有重要应用。

队列也有多种不同的类型，包括但不限于：
- **线性队列**：最基本的队列，按照FIFO原则进行操作。
- **循环队列**：在物理存储上是线性的，但逻辑上头尾相连形成一个环状结构，能更有效地利用存储空间。
- **优先队列**：每个元素都有一个优先级，元素出队的顺序由它们的优先级决定。
- **双端队列**（deque）：既可以在队头插入和删除元素，也可以在队尾插入和删除元素。

### 实现

#### 顺序表:

* 判空: front == back
* 入队: q[back++] = v
* 出队: v = q[front++]

#### 改进顺序表为循环队列

首先，对于队列的长度n，我们需要分配一个长度为n+1的数组来存储队列的元素，留出一个空间作为“保护位”。这样是为了区分队列为空和队列为满的情况。

假设我们有一个大小为n+1的数组q，初始时，队头和队尾指针front和back都指向0。那么循环队列的操作可以如下定义：

1. **判空**：当 front == back 时，队列为空。
2. **判满**：当 (back + 1) % (n + 1) == front 时，队列为满。这里用到了模运算来实现环状的逻辑结构。
3. **入队**：先判断队列是否满，如果不满，先在队尾位置存放新的元素：q[back] = v，然后更新队尾指针：back = (back + 1) % (n + 1)。
4. **出队**：先判断队列是否为空，如果不空，取出队头元素：v = q[front]，然后更新队头指针：front = (front + 1) % (n + 1)。

**这就是将顺序表改进为循环队列的一种常见方法，它通过牺牲一个数组单元的存储空间，使得队列的判满和判空操作变得简单，并且避免了数组元素的移动。**

#### 链表

* 判空: front == back 
* 入队: back->next = node; back = node
* 出队: v = front->v; node = front;  front = front->next; free(node);

### 双端队列

双端队列（Double Ended Queue，简称 Deque）是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列两端入队和出队。

输入受限双端队列:  在双端队列上删除了新增的输入端

输出受限双端队列:   在双端队列上删除了新增的输出端

### 做题方法

* **在循环顺序队列中, 一般采用 front指针的后一个元素才是队头元素, 或者说 front指向队头元素的前一个元素**, 用于做判满操作, <em style="color:red">但是需要注意的是, 我们要看清楚题目的意思, 有时候是让队尾指针back指向后一个, 有时候又不需要这个操作</em>
* 对于**输入受限的队列来说**,  看有哪些出队顺序不可能是他产生的方法是:  将这个出队顺序放入到输出受限队列中, 看他是否能够初入元素尝试这样一个队列,  比如  a b c d e  依次 入队 ,   对于 d b a c e 这个队列  它是能够产生的   先放入 a, 左b 右c 左d 右e,  而对于 d b c a e 它是不能够产生的, 因为左边出现了 b 在 c 之前,  总结:  **对于输出受限队列来说,  从第一个元素从两边依次遍历过去,  元素的入队顺序是不能变的**,  对于这个总结, 我们就可以自己产生输出受限队列不可能产生的队列:   bdfaec  baced  decab(a的左边,e 出现在了d的左边)



## 栈和队列的应用

### 括号匹配



### 表达式求值

在数学和计算机科学中，表达式（expression）是符号和运算符的有序组合，表示一种计算。根据运算符的位置，我们通常可以将表达式分为中缀表达式，前缀表达式（或叫波兰式）和后缀表达式（或叫逆波兰式）。

**中缀表达式（Infix Expression）**：
在中缀表达式中，运算符位于操作数之间。这是我们日常生活中最常用的表达式形式。例如：`2 + 3 * 4`。

**后缀表达式（Postfix Expression 或 Reverse Polish Notation）**：
在后缀表达式中，运算符位于所有操作数的后面。例如，中缀表达式 `2 + 3 * 4` 对应的后缀表达式为 `2 3 4 * +`。

转换中缀表达式为后缀表达式的一个常见方法是使用一个栈来保存运算符，这个方法通常被称为“调度场算法”。

这两种表达式方式的一个重要区别是，在中缀表达式中运算符有优先级，需要用括号来改变运算顺序，而后缀表达式则不需要。这使得后缀表达式在计算机中处理起来更为方便，因为计算后缀表达式只需从左到右扫描一遍，不需要记住运算符的优先级，也不需要处理括号。



**中缀表达式 转后缀表达式**

例如:  A+B*(C-D) -E/F

一个用于存放操作符栈 st_op

一个用于存放中缀表达式的队列 q

依次遍历中缀表达式   A 入队列,  + 入栈;  B入队列;  *入栈;  (入栈; C入队列;  - 入栈; D 入队列; )将栈中(之前的元素全部出栈入队列 -入队列, 弹出(; - 将前面全部操作符出栈 有 * +,  E入队列; /入栈; F入队列; 弹出全部操作符到队列

A B C D - * + E F / -  

上面就涉及到了优先级的问题, 当前栈顶优先级比自己高, 就弹出它放入到队列

### 递归


递归是一种编程技术，其中一个函数通过直接或间接地调用自身来解决问题。**递归函数通常被用来解决可以通过更小子问题的解来找到原问题解的那种问题。**

一个递归的实现通常包括以下两个主要部分：

1. **基本情况也叫边界条件（Base Case）**：这是递归调用链条中的最小问题，可以直接解决而不需要进一步的递归调用。基本情况的处理是递归函数正确工作的关键。
2. **递归调用（Recursive Case）**：在递归调用部分，函数会将问题分解为更小的子问题，并通过递归调用自身来解决这些子问题。

在编写递归函数时，需要特别注意避免无限递归，也就是说，我们需要保证在有限步骤内，每个递归调用都能到达一个基本情况。

递归在算法设计中是一个非常强大的工具，可以用来解决很多问题，比如搜索问题，排序问题（例如快速排序和归并排序），动态规划问题等。同时，很多数据结构，比如树和图，也有很多递归的操作。

### 队列在计算机系统中的应用

队列是计算机科学中一个非常重要的数据结构，它在各种不同的计算机系统中都有着广泛的应用。下面是一些常见的应用场景：

1. **操作系统**：在操作系统中，多个进程可能会共享一个单一的处理器。操作系统使用一个进程队列来管理这些进程，按照一定的调度策略（比如先进先出、优先级调度等）来决定下一个要运行的进程。

2. **打印任务管理**：在一个网络打印机中，打印任务会被放入一个队列中，打印机会按照队列中的顺序（通常是先进先出）依次打印。

3. **网络请求处理**：在Web服务器中，服务器会用一个队列来管理来自客户端的请求，按照队列的顺序依次处理这些请求。当服务器的处理能力有限时，队列可以用来平衡请求的处理速度和请求的到达速度，防止服务器被过多的请求压垮。

4. **消息队列**：在分布式系统中，消息队列是一种常见的数据交换方式。它允许不同的系统或者服务之间异步地交换信息。每个发送的消息都会被放入队列中，接收者可以从队列中取出并处理消息。

5. **图形化用户界面**：在图形用户界面中，事件（比如点击、按键、鼠标移动等）会被放入一个事件队列中，然后按照队列的顺序被处理。这样可以确保事件的处理顺序与事件的发生顺序一致。

6. **数据缓冲**：队列也常用于数据的缓冲，例如，在I/O操作，网络传输，生产者/消费者问题中，都可能使用队列作为数据的缓冲结构。

这些仅仅是队列在计算机系统中应用的一部分例子，队列的应用场景非常广泛。

## 数组和特殊矩阵

矩阵在计算机图形学和工程计算中有举足轻重的地位, 在数据结构中如何用最小的存储空间来存储矩阵变的格外重要.

### 数组

数组是一种基本的数据结构，用于存储同一类型的连续元素。以下是关于数组的一些基本知识：

**定义与特性**：

1. **连续存储**：数组中的元素在内存中是连续存储的，这意味着数组的每个元素都紧接着前一个元素存储。这使得可以通过基地址和偏移量快速定位和访问数组中的任意元素。

2. **固定大小**：在大多数编程语言中，数组在创建时需要指定大小，且之后无法改变。

3. **索引访问**：数组中的每个元素都可以通过索引（通常是整数）来访问，这通常是从0开始的。

**常见操作**：

1. **读取**：通过索引来读取元素，这是一个常数时间的操作。

2. **更新**：通过索引来更新元素，这也是一个常数时间的操作。

3. **搜索**：查找一个特定的元素在数组中的位置。在无序数组中，这通常需要遍历整个数组，所以时间复杂度是O(n)。在有序数组中，可以使用二分搜索，时间复杂度是O(log n)。

4. **插入和删除**：在数组的末尾插入或删除元素是一个常数时间的操作。但在数组的开头或中间插入或删除元素需要移动元素，所以时间复杂度是O(n)。

**应用场景**：

1. **存储数据**：数组是存储和处理大量数据的基础，例如图像处理、数值计算等。

2. **查找表/映射**：如果关键字是小整数，数组可以作为查找表或映射，通过关键字直接访问元素。

3. **实现其他数据结构**：数组是许多其他数据结构的基础，例如栈、队列、堆、哈希表等。

**注意事项**：

1. **越界问题**：由于数组的大小是固定的，所以访问数组时需要确保索引不越界。

2. **内存利用**：如果数据的数量或大小有大的变化，可能需要动态的数据结构，例如链表或动态数组，以更有效地使用内存。

### 特殊矩阵的压缩

#### 对称矩阵

**对称矩阵**:  上三角和下三角元素相同, 因此我们可以只存放下三角和主对角线的元素

用一个数组b来存放(下标从0开始)

获取 a(i,j)元素的公式为: 

a(i,j) = b[k]  其中  当i>=j 时 k = i\*(i-1)/2 + j-1  当 i<j 时  k = j\*(j-1) /2+ i-1



#### 三角矩阵

**上三角元素全部相同,下三角不同矩阵压缩**:   只需要先存储下三角, 然后再存放上上三角一个元素就行, 总共 存放n(n+1)/2 +1 个元素

a(i,j) = b[k] 其中当i>=j 时 k = i\*(i-1)/2 + j-1  当 i<j 时  k = n(n+1)/2

**下三角元素全部相同,上三角不同矩阵压缩**: 

a(i,j) = b[k] 其中当i>j 时 k = n(n+1)/2, 当 i<=j 时   k = (2*n-i+2)\*(i-1)/2 + j-i 

#### 三对角矩阵

三对角矩阵是一种特殊的矩阵，它只有主对角线上的元素以及主对角线两侧的元素（也就是对角线上的元素和对角线上下一行和上一列的元素）是非零的，其他位置的元素都是零。

假设我们有一个三对角矩阵，我们可以使用一个一维数组来存储非零元素，以节省存储空间。对于三对角矩阵，我们可以定义如下寻址公式（下标从0开始）：

设矩阵元素 a[i][j] 存在数组 b 中的位置 k，那么我们有：

```
b[k] = a[i][j] 其中 k = 2*i + j - 3 
```

已知k能够推出i和j   i = (k+1)/3+1 j = k-2*i+3  这里的除法是c语言里面的取整除法

#### 稀疏矩阵

**矩阵中非零元素的个数 $t$, 相对矩阵元素的个数 $s$ 来说非常少, 即 $s \gg t$ 的矩阵称为稀䟽矩阵**。 例如, 一个矩阵的阶为 $100 \times 100$, 该矩阵中只有少于 100 个非零元素。
若采用常规的方法存储稀疏矩阵, 则相当浪费存储空间, 因此仅存储非零元素。但通常非零 元素的分布没有规律, 所以仅存储非零元素的值是不够的, 还要存储它所在的行和列。因此, 将非零元素及其相应的行和列构成一个三元组 (行标, 列标, 值),。然后按照某种 规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。

**十字链表法存储**

十字链表是一种存储稀疏矩阵的方法，特别适合于非零元素分布比较均匀的稀疏矩阵。这种方法既可以快速访问任一元素，又可以快速对任一元素进行插入或删除操作。

在十字链表中，每个非零元素都对应一个结点，每个结点有5个字段：行、列、值、行的下一个元素、列的下一个元素。整个矩阵还有两个额外的头结点数组，分别表示每行和每列的第一个元素。

具体来说，设稀疏矩阵的行数为m，列数为n，那么十字链表包含如下内容：

1. 一维数组row[m]，表示m行的头结点，其中row[i]指向第i行的第一个非零元素。
2. 一维数组col[n]，表示n列的头结点，其中col[j]指向第j列的第一个非零元素。
3. 非零元素的结点，包含5个字段：行、列、值、行的下一个元素、列的下一个元素。

十字链表法优点是在查找元素、插入元素和删除元素时，既可以沿着行方向操作，也可以沿着列方向操作。缺点是存储空间较大，因为每个非零元素都需要存储额外的信息（行、列、下一个行元素、下一个列元素）。

### 总结

一定要记得这几个公式,  这样我们就能以不变应万变,   我们的公式 都是基于:  矩阵下标从1开始,  存放数组下标从0开始,  无论它题目从什么开始,  按行或者按列  或者上三角下三角,  我们都能转换到这几个公式上来

对称矩阵按照下三角按行存储   ==  **对称矩阵按照上三角按列存储 交换i j位置**
$$
k= \begin{cases}\frac{i(i-1)}{2}+j-1, & i \geqslant j \text { (下三角区和主对角线元素) } \\ \frac{j(j-1)}{2}+i-1, & \left.i<j \text { (上三角区元素 } a_{i j}=a_{j i}\right)\end{cases}
$$
对称矩阵按照上三角按行存储 ==  **对称矩阵按照下三角按行存储 交换i j 位置**
$$
k= \begin{cases}\frac{(i-1)(2 n-i+2)}{2}+(j-i), & i \leqslant j \text { (上三角区和主对角线元素) } \\ \frac{(j-1)(2 n-j+2)}{2}+(i-j), & i>j \text { (下三角区元素) }\end{cases}
$$
三角矩阵按照上三角按行存储 
$$
k= \begin{cases}\frac{(i-1)(2 n-i+2)}{2}+(j-i), & i \leqslant j \text { (上三角区和主对角线元素) } \\ \frac{n(n+1)}{2}, & i>j \text { (下三角区元素) }\end{cases}
$$


三对角矩阵

 3 条对角线上的元素 $a_{i j}(1 \leqslant i, j \leqslant n$, $|i-j| \leqslant 1)$ 在一维数组 B 中存放的下标为 $k=2 i+j-3$ 。

反之, 若已知三对角线矩阵中某元素 $a_{i, j}$ 存放于一维数组 B 的第 $k$ 个位置, 则可得 $i=\lfloor(k+1) /$ $3+1\rfloor, j=k-2 i+3$ 。例如, 当 $k=0$ 时, $i=\lfloor(0+1) / 3+1\rfloor=1, j=0-2 \times 1+3=1$, 存放的是 $a_{1,1}$; 当 $k=2$ 时, $i=\lfloor(2+1) / 3+1\rfloor=2, j=2-2 \times 2+3=1$, 存放的是 $a_{2,1}$; 当 $k=4$ 时, $i=\lfloor(4+1) / 3+1\rfloor$ $=2, j=4-2 \times 2+3=3$, 存放的是 $a_{2,3}$ 。

# 串

## 前言

大纲只要求掌握字符串的模式匹配,  我们要终点掌握kmp算法的原理以及next数组的推理过程

## 定义

串是由零个或者多个字符组成的有限序列,  串中任意多个连续的字符组成的子序列称为子串

两个串的长度,以及内容相等,那就说明两个串相等

## 串的模式匹配

这个通常是定位子串在主串中出现的位置

### 暴力匹配

假设 子串长度为 l 主串长度为 L   依次枚举主串中从当前下标开始连续的l个元素是否和子串相等, 这个效率太低下了 时间复杂度为 O(mn)





# 树与二叉树

# 图

# 查找

# 排序

# 额外补充

## 存储密度

存储密度是衡量数据存储效率的一个重要指标，它表示数据元素值所占存储空间与数据结构总占用存储空间的比率。公式表达如下：

存储密度 = **数据元素值所占存储空间 / 数据结构总占用存储空间**

数据元素值所占存储空间是指实际存储数据元素值所需的空间，而数据结构总占用存储空间则是包括存储数据元素值、元素之间的关系以及其他信息所需的全部空间。

存储密度的值介于0和1之间，值越接近1，表示存储利用率越高，空间效率越高。反之，值越接近0，表示存储利用率越低，空间效率越低。

例如，在顺序存储结构中，只需要存储数据元素本身，没有额外的空间需求，因此存储密度接近或等于1。**而在链式存储结构中，除了存储数据元素本身，还需要额外的空间来存储指向下一元素的指针，因此其存储密度一般小于1。**